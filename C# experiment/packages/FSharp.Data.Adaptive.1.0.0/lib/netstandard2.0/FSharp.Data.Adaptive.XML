<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Data.Adaptive</name></assembly>
<members>
<member name="F:FSharp.Data.Adaptive.ShallowEqualityComparer`1.instance">
<summary>
 TODO: better way?
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DefaultEqualityComparer.SetProvider(FSharp.Data.Adaptive.IEqualityProvider)">
<summary>
 handle with care!!
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ElementOperation`1.Remove">
<summary>
 Remove the associated key.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ElementOperation`1.Set">
<summary>
 Set the associated key to a specific value.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ElementOperation`1">
<summary>
 Reprensents a element operation (Set/Remove) without its key.
 Typically datastructures will hold (key * ElementOperation) tuples.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.SetOperation`1.Value">
<summary>
 The added/removed value
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.SetOperation`1.Inverse">
<summary>
 The inverse SetOperation to this one.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.SetOperation`1.Count">
<summary>
 The reference count delta.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.SetOperation`1">
<summary>
 Represents a set operation (Add/Remove) using a reference count.
 Note that internally SetOperations may have reference counts &gt; 1 and &lt; -1.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.Index">
<summary>
 datastructure representing an abstract index.
 this is a &apos;simple&apos; solution to the order-maintenance problem that has insert in O(log N), delete in O(1) and compare in O(1).
 Note that the implementation is quite obfuscated due to concurrency.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IndexListEnumerator`1">
<summary>
 Enumerator for IndexList.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.MinIndex">
<summary>
 The smallest Index contained in the list or Index.zero if the list is empty.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.MaxIndex">
<summary>
 The largest Index contained in the list or Index.zero if the list is empty.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.Item(System.Int32)">
<summary>
 Gets the entry at the given index or fails if not existing.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.Item(FSharp.Data.Adaptive.Index)">
<summary>
 Gets the entry associated to the given index or fails if not existing.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.IsEmpty">
<summary>
 Is the list empty?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.Empty">
<summary>
 The empty list.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.Count">
<summary>
 The number of entries in the list.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.Content">
<summary>
 Internal for getting the underlying store.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.AsSeqBackward">
<summary>
 Returns all entres from the list in back-to-front order.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.AsSeq">
<summary>
 Returns all entres from the list.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.AsListBackward">
<summary>
 Returns all entres from the list in back-to-front order.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.AsList">
<summary>
 Returns all entres from the list.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.AsArrayBackward">
<summary>
 Returns all entres from the list in back-to-front order.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexList`1.AsArray">
<summary>
 Returns all entres from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.UpdateTo``2(FSharp.Data.Adaptive.IndexList{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{`0},Microsoft.FSharp.Core.FSharpFunc{``0,``1}}})">
<summary>
 Like choose2 but with existing right values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Update(System.Int32,Microsoft.FSharp.Core.FSharpFunc{`0,`0})">
<summary>
 Updates the element at the given position or returns the unmodified list if the index was out of bounds.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryRemove(FSharp.Data.Adaptive.Index)">
<summary>
 Removes the entry associated to the given index, returns the (optional) value and the list without the specific element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryGetPrev(FSharp.Data.Adaptive.Index)">
<summary>
 Gets the element directly before index in the list (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryGetPosition(FSharp.Data.Adaptive.Index)">
<summary>
 Gets the position for the given index or None if the index is not contained in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryGetNext(FSharp.Data.Adaptive.Index)">
<summary>
 Gets the element directly after index in the list (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryGetIndex(System.Int32)">
<summary>
 Gets the index for the given position or None if the index is out of bounds.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryGet(System.Int32)">
<summary>
 Gets the entry at the given index (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryGet(FSharp.Data.Adaptive.Index)">
<summary>
 Gets the entry associated to the given index (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.TryFind(`0)">
<summary>
 Tries to find the smallest index for the given element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Set(System.Int32,`0)">
<summary>
 Updates the element at the given position or returns the unmodified list if the index was out of bounds.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Set(FSharp.Data.Adaptive.Index,`0)">
<summary>
 Adds or updates the element associated to index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.RemoveAt(System.Int32)">
<summary>
 Removes the entry at the given position (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Remove(`0)">
<summary>
 Removes the first occurrence of the given element (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Remove(FSharp.Data.Adaptive.Index)">
<summary>
 Removes the entry associated to the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Prepend(`0)">
<summary>
 Prepends the given element to the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.PairwiseCyclic">
<summary>
 Returns a list of each element tupled with its successor and the last element tupled with the first.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Pairwise">
<summary>
 Returns a list of each element tupled with its successor. 
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.NewIndexBefore(FSharp.Data.Adaptive.Index)">
<summary>
 Gets an unused index directly before the given one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.NewIndexAfter(FSharp.Data.Adaptive.Index)">
<summary>
 Gets an unused index directly after the given one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Neighbours(FSharp.Data.Adaptive.Index)">
<summary>
 Finds the optional neighbour elements in the list for the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Map``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{`0,``0}})">
<summary>
 Applies the mapping function to all elements of the list and returns a new list containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.InsertBefore(FSharp.Data.Adaptive.Index,`0)">
<summary>
 Inserts the element directly before the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.InsertAt(System.Int32,`0)">
<summary>
 Inserts the element at the given position or returns the unmodified list if the index is not in [0..count].
 Note that InsertAt works with index = count.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.InsertAfter(FSharp.Data.Adaptive.Index,`0)">
<summary>
 Inserts the element directly after the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.IndexOf(FSharp.Data.Adaptive.Index)">
<summary>
 Tries to find the position for the given Index or -1 if the Index does not exist. O(log N)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.IndexOf(`0)">
<summary>
 Tries to find the position for the given entry or -1 if the entry does not exist. O(N)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Filter(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean}})">
<summary>
 Filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.CopyTo(`0[],System.Int32)">
<summary>
 Copies the list to the given array (starting at index)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.ConservativeEquals(FSharp.Data.Adaptive.IndexList{`0})">
<summary>
 Conservatively determines whether the two IndexLists are equal.
 `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Choose``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 Applies the mapping function to all elements of the list and returns a new list containing all Some entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexList`1.Add(`0)">
<summary>
 Appends the given element to the list.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IndexList`1">
<summary>
 A persitent array-like structure that allows lookup/insertion/deletion of entries in O(log N).
 Note that datastructure uses Index instead of int as index type which allows for these efficient implementations.
 However the datastructure also has accessors that allow getting/setting/deleting entries via an int-index in O(log N).
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.DHashSetEnumerator`1">
<summary>
 Special enumerator for HashSetDelta.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Store">
<summary>
 The internal store used by the HashSetDelta.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.FSharpHashSetDelta`1.IsEmpty">
<summary>
 Is the set empty?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Inverse">
<summary>
 The inverse operations for the given set.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Empty">
<summary>
 The empty set.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Count">
<summary>
 The number of operations contained in the HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.ToSeq">
<summary>
 Creates a seq containing all operations from the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.ToMap">
<summary>
 Creates a HashMap containing all operations from the set.
 Note that this works in O(1).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.ToList">
<summary>
 Creates a list containing all operations from the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.ToArray">
<summary>
 Creates an array containing all operations from the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Remove(FSharp.Data.Adaptive.SetOperation{`0})">
<summary>
 Removes a SetOperation from the HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.OfSeq(System.Collections.Generic.IEnumerable{FSharp.Data.Adaptive.SetOperation{`0}})">
<summary>
 Creates a HashSetDelta using the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.OfList(Microsoft.FSharp.Collections.FSharpList{FSharp.Data.Adaptive.SetOperation{`0}})">
<summary>
 Creates a HashSetDelta using the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.OfArray(FSharp.Data.Adaptive.SetOperation{`0}[])">
<summary>
 Creates a HashSetDelta using the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Map``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},FSharp.Data.Adaptive.SetOperation{``0}})">
<summary>
 Applies the mapping function to all operations in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Iter(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},Microsoft.FSharp.Core.Unit})">
<summary>
 Iterates over all operations in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Forall(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},System.Boolean})">
<summary>
 Checks whether all entries fulfill the predicate exists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Fold``1(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},``0}})">
<summary>
 Folds over the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Filter(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},System.Boolean})">
<summary>
 Filters the operations contains using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Exists(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},System.Boolean})">
<summary>
 Checks whether an entry fulfilling the predicate exists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Combine(FSharp.Data.Adaptive.FSharpHashSetDelta{`0})">
<summary>
 Combines two DHashSets to one using a reference counting implementation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Collect``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0}})">
<summary>
 Applies the mapping function to all operations in the set and combines all the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Choose``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{`0},Microsoft.FSharp.Core.FSharpOption{FSharp.Data.Adaptive.SetOperation{``0}}})">
<summary>
 Applies the mapping function to all operations in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashSetDelta`1.Add(FSharp.Data.Adaptive.SetOperation{`0})">
<summary>
 Adds a SetOperation to the HashSetDelta.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.FSharpHashSetDelta`1">
<summary>
 Represents the difference of two HashSets.
 Internally uses reference counts to represent deltas and provides 
 convenient combine functions.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.FSharpHashMapDelta`2.Store">
<summary>
 The internal store used by the HashMapDelta.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.FSharpHashMapDelta`2.Empty">
<summary>
 The empty map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.FSharpHashMapDelta`2.Combine(FSharp.Data.Adaptive.FSharpHashMapDelta{`0,`1})">
<summary>
 Combines two DHashMaps to one.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.FSharpHashMapDelta`2">
<summary>
 Represents the difference of two HashMaps.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexListDelta`1.IsEmpty">
<summary>
 Is the list empty?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexListDelta`1.Empty">
<summary>
 The empty delta.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexListDelta`1.Count">
<summary>
 The number of deltas in the list.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexListDelta`1.Content">
<summary>
 Internally used for getting the underlying store.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.ToSeq">
<summary>
 Returns all Index/Operation tuples from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.ToList">
<summary>
 Returns all Index/Operation tuples from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.ToArray">
<summary>
 Returns all Index/Operation tuples from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.Remove(FSharp.Data.Adaptive.Index)">
<summary>
 Removes the operation associated to index. (if any)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.MapMonotonic``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{`0},System.Tuple{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0}}}})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the &apos;Some&apos;-results.
 Note that the indices need to be monotonic.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.Map``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{`0},FSharp.Data.Adaptive.ElementOperation{``0}}})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.Filter(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{`0},System.Boolean}})">
<summary>
 Filters the delta list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.Combine(FSharp.Data.Adaptive.IndexListDelta{`0})">
<summary>
 Combines to IndexListDeltas to one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.Collect``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{`0},FSharp.Data.Adaptive.IndexListDelta{``0}}})">
<summary>
 Applies the mapping function to all elements and combines the resulting lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.ChooseMonotonic``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{`0},Microsoft.FSharp.Core.FSharpOption{System.Tuple{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0}}}}})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the &apos;Some&apos;-results.
 Note that the indices need to be monotonic.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.Choose``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{`0},Microsoft.FSharp.Core.FSharpOption{FSharp.Data.Adaptive.ElementOperation{``0}}}})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the &apos;Some&apos;-results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDelta`1.Add(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{`0})">
<summary>
 Inserts an operation.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IndexListDelta`1">
<summary>
 Represents the difference of two IndexLists.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.MultiSetMap`2">
<summary>
 A simple multi-map implementation.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.TransactQueue`1.IsEmpty">
<summary>
 Is the queue emoty?
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactQueue`1.Enqueue(System.Int32,`0)">
<summary>
 Enqueue a key/value pair to the queue.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactQueue`1.Dequeue">
<summary>
 Dequeues the minimal element from the queue and returns the key/value pair
 as a struct tuple.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactQueue`1.Contains(`0)">
<summary>
 Does the queue contain the given value?
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.TransactQueue`1">
<summary>
 Implements a priority queue (with int as priority) where each
 &apos;V (by reference) can only be enqueued once.
 Note that the order for &apos;colliding&apos; keys is undefined.
</summary>
</member>
<member name="F:FSharp.Data.Adaptive.Cache`2.nullCache">
<summary>
 cache for null values (needed for option, unit, etc.)
</summary>
</member>
<member name="F:FSharp.Data.Adaptive.Cache`2.cache">
<summary>
 cache for non-null values.
</summary>
</member>
<member name="F:FSharp.Data.Adaptive.Cache`2.isNull">
<summary>
 utility checking for null (if possible)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Cache`2.Values">
<summary>
 Enumerate over all cache values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Cache`2.RevokeAndGetDeletedTotal(`0)">
<summary>
 Revoke returns the function value associated
 With the given argument and decreases its reference count.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Cache`2.RevokeAndGetDeleted(`0)">
<summary>
 Revoke returns the function value associated
 With the given argument and decreases its reference count.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Cache`2.Revoke(`0)">
<summary>
 Revoke the value and return its associated cache value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Cache`2.Invoke(`0)">
<summary>
 Invoke returns the function value associated
 With the given argument (possibly executing the function)
 And increases the associated reference count.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Cache`2.Clear(Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit})">
<summary>
 Clear removes all entries from the Cache and
 executes a function for all removed cache entries.
 This function is helpful if the contained values
 are (for example) disposable resources.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.Cache`2">
<summary>
 Cache represents a cached function which can be 
 invoked and revoked. invoke increments the reference
 count for a specific argument (possibly causing the 
 function to be executed) whereas revoke decreases the
 eeference count and removes the cache entry whenever
 the reference count is 0.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.WeakOutputSet.IsEmpty">
<summary>
 Indicates whether the set is (conservatively) known to be empty.
 Note that we don&apos;t dereference any WeakReferences here.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.WeakOutputSet.Remove(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Removes the reference to the given AdaptiveObject from the set
 And returns a boolean indicating whether the obj was removed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.WeakOutputSet.Consume(Microsoft.FSharp.Core.FSharpRef{FSharp.Data.Adaptive.IAdaptiveObject[]})">
<summary>
 Returns all currenty living entries from the set
 And clears its content.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.WeakOutputSet.Cleanup">
<summary>
 Used interally to get rid of leaking WeakReferences
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.WeakOutputSet.Add(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Adds a weak reference to the given AdaptiveObject to the set
 And returns a boolean indicating whether the obj was new.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.WeakOutputSet">
<summary>
 Represents a set of outputs for an AdaptiveObject. The references to all
 contained elements are weak and the datastructure allows to add/remove
 entries. The only other functionality is Consume which returns all the
 (currently live) entries and clears the set.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.VolatileSetData">
<summary>
 Datastructure for zero-cost casts between different possible representations for WeakOutputSet.
 We actually did experiments and for huge dependency graphs transactions were ~10% faster 
 than they were when using unbox.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IWeakOutputSet.IsEmpty">
<summary>
 Indicates whether the set is (conservatively) known to be empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IWeakOutputSet.Remove(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Removes the reference to the given AdaptiveObject from the set
 And returns a boolean indicating whether the obj was removed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IWeakOutputSet.Consume(Microsoft.FSharp.Core.FSharpRef{FSharp.Data.Adaptive.IAdaptiveObject[]})">
<summary>
 Returns all currenty living entries from the set
 And clears its content.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IWeakOutputSet.Clear">
<summary>
 Clears the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IWeakOutputSet.Add(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Adds a weak reference to the given AdaptiveObject to the set
 And returns a boolean indicating whether the obj was new.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IWeakOutputSet">
<summary>
 Represents a set of outputs for an AdaptiveObject. The references to all 
 contained elements are weak and the datastructure allows to add/remove entries.
 the only other functionality is Consume which returns all the (currently alive)
 entries and clears the set.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveObject.OutOfDate(System.Boolean)">
<summary>
 Indicates whether the object has been marked. This flag should only be accessed when holding
 a lock on the adaptive object.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveObject.Level(System.Int32)">
<summary>
 Used internally to represent the maximal distance from an input
 cell in the dependency graph when evaluating inside a transaction.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveObject.Weak">
<summary>
 Each object can cache a WeakReference pointing to itself.
 This is because the system internally needs WeakReferences to IAdaptiveObjects
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveObject.Outputs">
<summary>
 The adaptive outputs for the object. Represented by Weak references to allow for
 unused parts of the graph to be garbage collected.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveObject.OutOfDate">
<summary>
 Indicates whether the object has been marked. This flag should only be accessed when holding
 a lock on the adaptive object.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveObject.Level">
<summary>
 Used internally to represent the maximal distance from an input
 cell in the dependency graph when evaluating inside a transaction.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveObject.IsConstant">
<summary>
 Indicates whether the IAdaptiveObject is constant
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveObject.Mark">
<summary>
 Allows a specific implementation to evaluate the cell during the change propagation process.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveObject.InputChanged(System.Object,FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Gets called whenever a current input of the object gets marked
 out of date. The first argument represents the Transaction that
 causes the object to be marked
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveObject.AllInputsProcessed(System.Object)">
<summary>
 Gets called after all inputs of the object have been processed
 and directly before the object will be marked
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IAdaptiveObject">
<summary>
 Represents the core interface for all adaptive objects.
 Contains support for tracking OutOfDate flags, managing in-/outputs 
 and lazy/eager evaluation in the dependency tree.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.Running(Microsoft.FSharp.Core.FSharpOption{FSharp.Data.Adaptive.Transaction})">
<summary>
 Gets or sets the transaction currently running on this thread (if any)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.Current(Microsoft.FSharp.Core.FSharpOption{FSharp.Data.Adaptive.Transaction})">
<summary>
 Gets or sets the transaction currently being built on this thread (via transact (fun () -&gt; ...))
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.RunningLevel">
<summary>
 Gets the level of the currently running Transaction or
 Int32.MaxValue when no Transaction is running
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.Running">
<summary>
 Gets or sets the transaction currently running on this thread (if any)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.HasRunning">
<summary>
 Indicates if inside a running Transaction
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.CurrentLevel">
<summary>
 Gets the current Level the Transaction operates on
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.CurrentAdapiveObject">
<summary>
 Gets the current AdaptiveObject being marked
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.Transaction.Current">
<summary>
 Gets or sets the transaction currently being built on this thread (via transact (fun () -&gt; ...))
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Transaction.Enqueue(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Enqueues an adaptive object for marking
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Transaction.Dispose">
<summary>
 Disposes the transaction running all of its &quot;Finalizers&quot;
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.Transaction.Commit">
<summary>
 Performs the entire marking process, causing all affected objects to
 be made consistent with the enqueued changes.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.Transaction">
<summary>
 The new level for the top-level object.
 Holds a set of adaptive objects which have been changed and shall
 therefore be marked as outOfDate. Committing the transaction propagates
 these changes into the dependency-graph, takes care of the correct
 execution-order and acquires appropriate locks for all objects affected.
</summary>
</member>
<member name="F:FSharp.Data.Adaptive.AdaptiveToken.caller">
<summary>
 Represents the calling IAdaptiveObject or null if none.

 Note, this is only mutable because that exposes the underlying field
 for (reportedly) more performant access.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveToken.Top">
<summary>
 The top-level AdaptiveToken without a calling IAdaptiveObject
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveToken.WithCaller(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Creates a new AdaptiveToken with the given caller
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveToken.#ctor(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Creates a new AdaptiveToken using the given caller
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.AdaptiveToken">
<summary>
 AdaptiveToken represents a token that can be passed to
 inner AdaptiveObjects for evaluation.
 when passing an AdaptiveToken to the evaluation-function of 
 a cell the system will create a dependency edge internally and
 future marking of the inner cell will also cause the calling cell to
 be marked.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ConstantObject">
<summary>
 Core implementation of IAdaptiveObject for constant objects.
 The main goal of this implementation is to save memory when IAdaptiveObjects are known to be constant.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.UnsafeEvaluationDepth(System.Int32)">
<summary>
 Used for resetting EvaluationDepth in eager evaluation
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.OutOfDate(System.Boolean)">
<summary>
 See IAdaptiveObject.OutOfDate
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.Level(System.Int32)">
<summary>
 See IAdaptiveObject.Level
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.Weak">
<summary>
 See IAdaptiveObject.Weak
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.UnsafeEvaluationDepth">
<summary>
 Used for resetting EvaluationDepth in eager evaluation
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.Outputs">
<summary>
 See IAdaptiveObject.Outputs
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.OutOfDate">
<summary>
 See IAdaptiveObject.OutOfDate
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveObject.Level">
<summary>
 See IAdaptiveObject.Level
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveObject.MarkObject">
<summary>
 See IAdaptiveObject.Mark()
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveObject.InputChangedObject(System.Object,FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 See IAdaptiveObject.InputChanged(transaction, object)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveObject.AllInputProcessedObject(System.Object)">
<summary>
 See IAdaptiveObject.AllInputsProcessed(transaction)
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.AdaptiveObject">
<summary>
 Core implementation of IAdaptiveObject containing tools for evaluation
 and locking
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.MultiCallbackObject.Subscribe(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean})">
<summary>
 adds a callback to the object. the returned boolean indicates whether the callback
 should automatically re-subscribe after being fired.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.MultiCallbackObject">
<summary>
 Represents an object providing callbacks in the dependency-tree
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.cval`1">
<summary>
 Represents an adaptive value that can be changed by application code and
 Used in dependency-aware computations.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableValue`1.Value(`0)">
<summary>
 Gets or sets the current value.
 Setting the value requires a Transaction to be active using `transact`.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableValue`1.Value">
<summary>
 Gets or sets the current value.
 Setting the value requires a Transaction to be active using `transact`.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableValue`1.UpdateTo(`0)">
<summary>
 Sets the current state of the cval.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableValue`1.GetValue(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Gets the current value and adds a dependency to the caller (if any)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableValue`1.#ctor(`0)">
<summary>
 Creates a new changeable value, intially holding the given value
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ChangeableValue`1">
<summary>
 Represents an adaptive value that can be changed by application code and
 Used in dependency-aware computations.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.aval`1">
<summary>
 An abbreviation for AdaptiveValue
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveValue`1.GetValue(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Evaluates the AdaptiveValue&lt;&apos;T&gt; using the given token and returns the current value.
 Dependencies will be tracked automatically when the token is correctly passed to all inner evaluation-calls.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IAdaptiveValue`1">
<summary>
 Represents a dependency-aware value that may change as changes are fed into the system.
 An AdaptiveValue cannot be changed directly but gets updated by the dependency graph. 
 For changeable inputs see cval&lt;&apos;T&gt;
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveValue.ContentType">
<summary>
 The (statically known) type of the returned value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveValue.GetValueUntyped(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Evaluates the AdaptiveValue using the given token and returns the current value.
 Dependencies will be tracked automatically when the token is correctly passed to all inner evaluation-calls.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IAdaptiveValue">
<summary>
 Represents a dependency-aware value that may change as changes are fed into the system.
 An AdaptiveValue cannot be changed directly but gets updated by the dependency graph. 
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveReduction`3.view">
<summary>
 The view function allows the result to be mapped to some other type.
 Note that reduce implementations internally assume that this is a very  cheap conversion.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveReduction`3.sub">
<summary>
 Subtraction function used when elements are removed.
 Note that it may return ValueNone in cases where the value can&apos;t be subtracted.
 However when doing so, the reduce implementations will fall back to recomputing the 
 result from scratch.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveReduction`3.add">
<summary>
 Addition function used to add new elements
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveReduction`3.seed">
<summary>
 The seed value for the reduction
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.AdaptiveReduction`3">
<summary>
 AdaptiveReduction holds operators for reducing collections adaptively.
 Its main purpose is to simplify reductions on ASet/AMap/AList.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.aset`1">
<summary>
 Adaptive set datastructure.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveHashSet`1.IsConstant">
<summary>
 Is the set constant?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveHashSet`1.History">
<summary>
 Gets the underlying History instance for the aset (if any)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveHashSet`1.Content">
<summary>
 The current content of the set as aval.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveHashSet`1.GetReader">
<summary>
 Gets a new reader to the set.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IAdaptiveHashSet`1">
<summary>
 Adaptive set datastructure.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IHashSetReader`1">
<summary>
 An adaptive reader for aset that allows to pull operations and exposes its current state.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.cset`1">
<summary>
 An abbreviation for ChangeableHashSet
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashSet`1.Value(FSharp.Data.Adaptive.FSharpHashSet{`0})">
<summary>
 Gets or sets the current state as HashSet.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashSet`1.Value">
<summary>
 Gets or sets the current state as HashSet.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashSet`1.IsEmpty">
<summary>
 Is the set currently empty?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashSet`1.Count">
<summary>
 The number of entries currently in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.UpdateTo(FSharp.Data.Adaptive.FSharpHashSet{`0})">
<summary>
 Sets the current state as HashSet.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Adds all the given values to the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.Remove(`0)">
<summary>
 Removes a value and returns whether the element was deleted.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Removes all elements from the set that are not also contained in other.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.GetReader">
<summary>
 Creates an adaptive reader for the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Removes all the given elements from the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.Contains(`0)">
<summary>
 Checks whether the given value is contained.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.Clear">
<summary>
 Clears the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.Add(`0)">
<summary>
 Adds a value and returns whether the element was new.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.#ctor(FSharp.Data.Adaptive.FSharpHashSet{`0})">
<summary>
 Creates a new cset containing all the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Creates a new cset containing all the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashSet`1.#ctor">
<summary>
 Creates a new empty cset.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ChangeableHashSet`1">
<summary>
 Changeable adaptive set that allows mutation by user-code and implements aset.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.amap`2">
<summary>
 Adaptive map datastructure.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveHashMap`2.IsConstant">
<summary>
 is the map constant?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveHashMap`2.History">
<summary>
 Gets the underlying History instance for the amap (if any)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveHashMap`2.Content">
<summary>
 the current content of the map as aval.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveHashMap`2.GetReader">
<summary>
 gets a new reader to the map.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IAdaptiveHashMap`2">
<summary>
 Adaptive map datastructure.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IHashMapReader`2">
<summary>
 An adaptive reader for amap that allows to pull operations and exposes its current state.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.cmap`2">
<summary>
 Changeable adaptive map that allows mutation by user-code and implements amap.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashMap`2.Value(FSharp.Data.Adaptive.FSharpHashMap{`0,`1})">
<summary>
 Gets or sets the current state as HashMap.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashMap`2.Item(`0,`1)">
<summary>
 Gets or sets the value associated to key.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashMap`2.Value">
<summary>
 Gets or sets the current state as HashMap.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashMap`2.Item(`0)">
<summary>
 Gets or sets the value associated to key.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashMap`2.IsEmpty">
<summary>
 Is the map currently empty?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableHashMap`2.Count">
<summary>
 The number of entries currently in the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.UpdateTo(FSharp.Data.Adaptive.FSharpHashMap{`0,`1})">
<summary>
 Sets the current state as HashMap.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.UpdateTo``1(FSharp.Data.Adaptive.FSharpHashMap{`0,``0},Microsoft.FSharp.Core.FSharpFunc{``0,`1},Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,`1}})">
<summary>
 Sets the current state as HashMap applying the init function to new elements and the update function to
 existing ones.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.TryGetValue(`0)">
<summary>
 Returns the (optional) value associated to key.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.Remove(`0)">
<summary>
 Removes the entry for the given key and returns whether the element was deleted.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.GetReader">
<summary>
 Creates an adaptive reader for the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.ContainsKey(`0)">
<summary>
 True if the map contains the given key.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.Clear">
<summary>
 Clears the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.Add(`0,`1)">
<summary>
 Adds the given key/value pair to the map and returns true when the map changed. (overrides existing values)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
<summary>
 Creates a new cmap containing all the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
<summary>
 Creates a new cmap containing all the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.#ctor(FSharp.Data.Adaptive.FSharpHashMap{`0,`1})">
<summary>
 Creates a new cmap containing all the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableHashMap`2.#ctor">
<summary>
 Creates a new empty cmap.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ChangeableHashMap`2">
<summary>
 Changeable adaptive map that allows mutation by user-code and implements amap.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.alist`1">
<summary>
 Adaptive list datastructure.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveIndexList`1.IsConstant">
<summary>
 Is the list constant?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveIndexList`1.History">
<summary>
 Gets the underlying History instance for the alist (if any)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IAdaptiveIndexList`1.Content">
<summary>
 The current content of the list as aval.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IAdaptiveIndexList`1.GetReader">
<summary>
 Gets a new reader to the list.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IAdaptiveIndexList`1">
<summary>
 Adaptive list datastructure.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IIndexListReader`1">
<summary>
 An adaptive reader for alist that allows to pull operations and exposes its current state.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.clist`1">
<summary>
 Changeable adaptive list that allows mutation by user-code and implements alist.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.Value(FSharp.Data.Adaptive.IndexList{`0})">
<summary>
 Gets or sets the value for the list.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.Item(FSharp.Data.Adaptive.Index,`0)">
<summary>
 Gets or sets the element associated to index.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.Item(System.Int32,`0)">
<summary>
 Gets or sets an element in the list at the given index.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.Value">
<summary>
 Gets or sets the value for the list.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.MinIndex">
<summary>
 The smallest index contained in the list (or Index.zero if empty)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.MaxIndex">
<summary>
 The largest index contained in the list (or Index.zero if empty)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.Item(FSharp.Data.Adaptive.Index)">
<summary>
 Gets or sets the element associated to index.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.Item(System.Int32)">
<summary>
 Gets or sets an element in the list at the given index.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.IsEmpty">
<summary>
 is the list currently empty?
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ChangeableIndexList`1.Count">
<summary>
 the number of elements currently in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.UpdateTo(FSharp.Data.Adaptive.IndexList{`0})">
<summary>
 Sets the current state as List.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.UpdateTo``1(FSharp.Data.Adaptive.IndexList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,`0},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,`0}})">
<summary>
 Sets the current state as List applying the init function to new elements and the update function to
 existing ones.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.TryGetPrev(FSharp.Data.Adaptive.Index)">
<summary>
 Tries to get the (index, value) for element directly before the given ref.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.TryGetNext(FSharp.Data.Adaptive.Index)">
<summary>
 Tries to get the (index, value) for element directly after the given ref.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.TryGetIndex(System.Int32)">
<summary>
 Tries to get the Index associated to the given position.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.TryGet(FSharp.Data.Adaptive.Index)">
<summary>
 Gets the (optional) element associated to the given Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.TryAt(System.Int32)">
<summary>
 Tries to get the element at the given position.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.RemoveAt(System.Int32)">
<summary>
 Removes the element at the given position and returns its Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.Remove(FSharp.Data.Adaptive.Index)">
<summary>
 Removes the given index from the list and returns true if the element was deleted.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.Prepend(`0)">
<summary>
 Prepends an element to the list and returns its Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.NewIndexBefore(FSharp.Data.Adaptive.Index)">
<summary>
 Returns a new (currently unused) index directly before the given one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.NewIndexAfter(FSharp.Data.Adaptive.Index)">
<summary>
 Returns a new (currently unused) index directly after the given one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.Neighbours(FSharp.Data.Adaptive.Index)">
<summary>
 Gets the neigbour elements and self (if existing) and returns (previous, self, next) as a triple.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.InsertBefore(FSharp.Data.Adaptive.Index,`0)">
<summary>
 Inserts an element directly before the given index and returns the new index for the element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.InsertAt(System.Int32,`0)">
<summary>
 Inserts an element at the given position in the list and returns its Index.
 Note that the position can be equal to the count of the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.InsertAfter(FSharp.Data.Adaptive.Index,`0)">
<summary>
 Inserts an element directly after the given index and returns the new index for the element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.Clear">
<summary>
 Clears the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.Append(`0)">
<summary>
 Appends an element to the list and returns its Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Appends all given elements to the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.Add(`0)">
<summary>
 Appends an element to the list and returns its Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.#ctor">
<summary>
 Creates a new empty list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Creates a new list initially holding the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ChangeableIndexList`1.#ctor(FSharp.Data.Adaptive.IndexList{`0})">
<summary>
 Creates a new list initially holding the given elements.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ChangeableIndexList`1">
<summary>
 Changeable adaptive list that allows mutation by user-code and implements alist.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.LevelChangedException">
<summary>
 When evaluating AdaptiveObjects inside a Transaction 
 (aka eager evaluation) their level might be inconsistent when
 attempting to evaluate. Therefore the evaluation may raise
 this exception causing the evaluation to be delayed to a later
 time in the Transaction.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.union``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a new map containing all elements from l and r.
 Colliding entries are taken from r.
 `O(N + M)`        
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.unionWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a new map containing all elements from l and r.
 The resolve function is used to resolve conflicts.
 `O(N + M)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Tests whether all entries fulfil the given predicate.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Tests whether an entry making the predicate true exists.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,FSharp.Data.Adaptive.FSharpHashMap{``1,``2})">
<summary>
 Folds over all entries of the map.
 Note that the order for elements is undefined.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Applies the iter function to all entries of the map.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a new map (with the same keys) that contains all entries for which predicate was true.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.chooseV``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpValueOption{``2}}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a new map (with the same keys) by applying the given function to all entries.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a new map (with the same keys) by applying the given function to all entries.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a new map (with the same keys) by applying the given function to all entries.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.update``2(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``1},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Adds, deletes or updates the entry for the given key.
 The update functions gets the optional old value and may optionally return
 A new value (or None for deleting the entry).
 `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.alter``2(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``1}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Adds, deletes or updates the entry for the given key.
 The update functions gets the optional old value and may optionally return
 A new value (or None for deleting the entry).
 `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.containsKey``2(``0,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Tests if an entry for the given key exists. `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.find``2(``0,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Finds the value for the given key and raises KeyNotFoundException on failure.
 `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.tryFindV``2(``0,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Tries to find the value for the given key.
 `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.tryFind``2(``0,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Tries to find the value for the given key.
 `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.tryRemoveV``2(``0,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Tries to remove the entry for the given key from the map and returns its value and the rest of the map.
 `O(log N)`       
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.tryRemove``2(``0,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Tries to remove the entry for the given key from the map and returns its value and the rest of the map.
 `O(log N)`       
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.remove``2(``0,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Removes the entry for the given key. `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.add``2(``0,``1,FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Adds or updates the entry for the given key. `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.toMap``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a Map holding all entries contained in the HashMap.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.toArray``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates an array holding all tuples contained in the map.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.toList``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a list holding all tuples contained in the map.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.toSeq``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates a seq holding all tuples contained in the map.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.ofArray``2(System.Tuple{``0,``1}[])">
<summary>
 Creates a map with all entries from the array.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.ofList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Creates a map with all entries from the list.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.ofMap``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Creates a map with all entries from the map.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Creates a map with all entries from the seq.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.single``2(``0,``1)">
<summary>
 Creates a map with a single entry.
 `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.isEmpty``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Is the map empty? `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.count``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 The number of elements in the map `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapModule.empty``2">
<summary>
 The empty map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.union``1(FSharp.Data.Adaptive.FSharpHashSet{``0},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a new map containing all elements from l and r.
 Colliding entries are taken from r.
 `O(N + M)`        
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Tests whether all entries fulfil the given predicate.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Tests whether an entry making the predicate true exists.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Data.Adaptive.FSharpHashSet{``1})">
<summary>
 Folds over all entries of the map.
 Note that the order for elements is undefined.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Applies the iter function to all entries of the map.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a new map (with the same keys) that contains all entries for which predicate was true.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a new map (with the same keys) by applying the given function to all entries.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a new map (with the same keys) by applying the given function to all entries.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.contains``1(``0,FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Tests if an entry for the given key exists. `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.tryRemove``1(``0,FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Tries to remove the given value from the set and returns the rest of the set.
 `O(log N)`       
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.remove``1(``0,FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Removes the given value. `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.add``1(``0,FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Adds the given value. `O(log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.toSet``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a Set holding all entries contained in the HashSet.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.toArray``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates an array holding all values.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.toList``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a list holding all values.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.toSeq``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a seq holding all values.
 `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.ofArray``1(``0[])">
<summary>
 Creates a set with all entries from the array.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates a set with all entries from the list.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.ofSet``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Creates a set with all entries from the Set.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a set with all entries from the seq.
 `O(N * log N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.single``1(``0)">
<summary>
 Creates a set with a single entry.
 `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.equals``1(FSharp.Data.Adaptive.FSharpHashSet{``0},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Are the sets equal? `O(N)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.isEmpty``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Is the set empty? `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.count``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 The number of elements in the set `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetModule.empty``1">
<summary>
 The empty set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetDeltaExtensions.|Add|Rem|``1(FSharp.Data.Adaptive.SetOperation{``0})">
<summary>
 Active pattern for SetOperation.
 Note that the patterns also returns the reference delta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetDeltaExtensions.SetOperation`1.Rem.Static``1(``0)">
<summary>
 Creates a remove operation (reference delta -1)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetDeltaExtensions.SetOperation`1.Add.Static``1(``0)">
<summary>
 Creates an add operation (reference delta +1)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetDeltaExtensions.Rem``1(``0)">
<summary>
 Creates a remove operation (reference delta -1)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetDeltaExtensions.Add``1(``0)">
<summary>
 Creates an add operation (reference delta +1)
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.SetDeltaExtensions">
<summary>
 SetOperation extensions making them look like a union-type.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetOperationModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.SetOperation{``0})">
<summary>
 Applies a mapping function to the operation&apos;s value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetOperationModule.inverse``1(FSharp.Data.Adaptive.SetOperation{``0})">
<summary>
 Inverts the operation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetOperationModule.rem``1(``0)">
<summary>
 Creates a remove operation (reference delta -1)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetOperationModule.add``1(``0)">
<summary>
 Creates an add operation (reference delta +1)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.SetOperationModule.create``1(System.Int32,``0)">
<summary>
 Creates a new SetOperation
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.SetOperationModule">
<summary>
 Functional operators for SetOperation&lt;_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexModule.between(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.Index)">
<summary>
 gets an index between the given ones.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexModule.before(FSharp.Data.Adaptive.Index)">
<summary>
 gets an index before the given one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexModule.after(FSharp.Data.Adaptive.Index)">
<summary>
 gets an index after the given one.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.IndexModule.zero">
<summary>
 the root index.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IndexModule">
<summary>
 functional operators for the Index datastructure.
 supported operations are: Index.zero, Index.after(index), Index.before(index), Index.between(l, r).
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.MapExtImplementation.MapTreeModule.MapIterator`2.started">
<summary>
 true when MoveNext has been called   
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.MapExtImplementation.MapTreeModule.MapIterator`2.stack">
<summary>
 invariant: always collapseLHS result 
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.MapExtImplementation.MapTreeModule.MapIterator`2">
<summary>
 Imperative left-to-right iterators.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.sortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 sorts the list using the given compare function.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.sortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 sorts the list by the given mapping in descending order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.sortByDescendingi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 sorts the list by the given mapping in descending order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 sorts the list by the given mapping.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.sortByi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 sorts the list by the given mapping.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.filteri``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.choose2``3(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2}}}},FSharp.Data.Adaptive.IndexList{``0},FSharp.Data.Adaptive.IndexList{``1})">
<summary>
 Creates a new IndexList by applying the mapping function to all entries.
 The respective option-arguments are some whenever the left/right list has an entry for the current Index.
 Note that one of the options will always be some.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 applies the mapping function to all elements in the list and drops None results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.choosei``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 applies the mapping function to all elements in the list and drops None results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.range``1(``0,``0)">
<summary>
 Create a list of the given length using the given initializer
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create a list of the given length using the given initializer
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 applies the mapping function to all elements in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 applies the mapping function to all elements in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IndexList{``1}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 applies the mapping function to all elements and concats the resulting lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.collecti``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IndexList{``1}}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 applies the mapping function to all elements and concats the resulting lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.ofArray``1(``0[])">
<summary>
 creates a list from the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 creates a list from the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 creates a list from the given elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toArrayBack``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list in reversed order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toListBack``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list in reversed order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toSeqBack``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list in reversed order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toArray``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toList``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toSeq``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.ofArrayIndexed``1(System.Tuple{FSharp.Data.Adaptive.Index,``0}[])">
<summary>
 creates a new IndexList containing all the given elements at their respective Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.ofListIndexed``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Data.Adaptive.Index,``0}})">
<summary>
 creates a new IndexList containing all the given elements at their respective Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.ofSeqIndexed``1(System.Collections.Generic.IEnumerable{System.Tuple{FSharp.Data.Adaptive.Index,``0}})">
<summary>
 creates a new IndexList containing all the given elements at their respective Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toArrayIndexedBack``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list with their respective Index in reveresed order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toListIndexedBack``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list with their respective Index in reveresed order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toSeqIndexedBack``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list with their respective Index in reveresed order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toArrayIndexed``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list with their respective Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toListIndexed``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list with their respective Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.toSeqIndexed``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 all elements from the list with their respective Index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.single``1(``0)">
<summary>
 creates a list containing a single element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.skip``1(System.Int32,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 skips the first n elements from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.take``1(System.Int32,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 takes the first n elements from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.concat``2(``0)">
<summary>
 concats the given lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.append``1(FSharp.Data.Adaptive.IndexList{``0},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 concats the given lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.pairwiseCyclic``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Returns a list of each element tupled with its successor and the last element tupled with the first.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.pairwise``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Returns a list of each element tupled with its successor.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryPickBack``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 tries to pick the last Some - value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 tries to pick the first Some - value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.findBack``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 finds the last entry satisfying the predicate or fails if none.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.find``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 finds the first entry satisfying the predicate or fails if none.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 tries to find the last entry satisfying the predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 tries to find the first entry satisfying the predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 checks if all elements in the list fulfill the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 checks whether any element in the list fulfills the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.findIndexBack``1(``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the index for the last occurrence of element in the list or fails if not existing.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.findIndex``1(``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the index for the first occurrence of element in the list or fails if not existing.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryFindIndexBack``1(``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 tries to get the index for the last occurrence of element in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryFindIndex``1(``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 tries to get the index for the first occurrence of element in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.last``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the last element from the list or fails if empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.first``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the first element from the list or fails if empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryLast``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the optional last element from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryFirst``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the optional first element from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.lastIndex``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the max-index used by the list or fails if empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.firstIndex``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the min-index used by the list or fails if empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryLastIndex``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the optional max-index used by the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryFirstIndex``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the optional min-index used by the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.splitAt``1(System.Int32,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 splits the list at the given index and returns both (possibly empty) halves and (optional) splitting element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.updateAt``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 updates the element at the given index (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.alterAt``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 adds, deletes or updates the element for the given index.
 the update functions gets the optional old value and may optionally return
 a new value (or None for deleting the entry).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryGetPosition``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the position for the given index or None if the index is not contained in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryAt``1(System.Int32,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the (optional) element for the index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.insertAt``1(System.Int32,``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 inserts a new element at the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.removeAt``1(System.Int32,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 removes the element at the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.setAt``1(System.Int32,``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 updates or creates the element at the given index.
 note that out-of-bounds-indices will be ineffective.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.split``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 splits the list at the given index and returns both (possibly empty) halves and (optional) splitting element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.update``1(FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``0},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 updates the element at the given index (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.alter``1(FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 adds, deletes or updates the element for the given index.
 the update functions gets the optional old value and may optionally return
 a new value (or None for deleting the entry).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryGet``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 gets the element for the given index (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.insertBefore``1(FSharp.Data.Adaptive.Index,``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 inserts an element directly before the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.insertAfter``1(FSharp.Data.Adaptive.Index,``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 inserts an element directly after the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryGetPrev``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Gets the element directly before index in the list (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryGetNext``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Gets the element directly after index in the list (if any).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.newIndexBefore``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Gets an unused index directly after the given one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.newIndexAfter``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Gets an unused index directly after the given one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.neighbours``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Finds the optional neighbour elements in the list for the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.tryRemove``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Removes the entry associated to the given index, returns the (optional) value and the list without the specific element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.remove``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 removes the element at the given index. (if any)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.set``1(FSharp.Data.Adaptive.Index,``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 updates or creates the element at the given index.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.prepend``1(``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 adds an element at the beginning of the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.add``1(``0,FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 adds an element at the end of the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.count``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 the number of entries in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.isEmpty``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 is the list empty?
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.empty``1">
<summary>
 the empty list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListModule.ofMap``1(FSharp.Data.Adaptive.MapExt{FSharp.Data.Adaptive.Index,``0})">
<summary>
 Internal utility for creating IndexLists from MapExt.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IndexListModule">
<summary>
 Functional operators for IndexList.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``1},``0}},``0,FSharp.Data.Adaptive.FSharpHashSetDelta{``1})">
<summary>
 Folds over the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``0},System.Boolean},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Checks whether all entries fulfill the predicate exists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``0},System.Boolean},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Checks whether an entry fulfilling the predicate exists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``0},Microsoft.FSharp.Core.Unit},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Iterates over all operations in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.collect``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``1}},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Applies the mapping function to all operations in the set and combines all the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``0},System.Boolean},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Filters the operations contains using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``0},Microsoft.FSharp.Core.FSharpOption{FSharp.Data.Adaptive.SetOperation{``1}}},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Applies the mapping function to all operations in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.map``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.SetOperation{``0},FSharp.Data.Adaptive.SetOperation{``1}},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Applies the mapping function to all operations in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.combine``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Combines two DHashSets to one using a reference counting implementation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.remove``1(FSharp.Data.Adaptive.SetOperation{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Removes a SetOperation from the HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.add``1(FSharp.Data.Adaptive.SetOperation{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Adds a SetOperation to the HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.toHashMap``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Creates a HashMap containing all operations from the set.
 Note that this works in O(1).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.toArray``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Creates an array containing all operations from the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.toList``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Creates a list containing all operations from the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.toSeq``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Creates a seq containing all operations from the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.ofHashMap``1(FSharp.Data.Adaptive.FSharpHashMap{``0,System.Int32})">
<summary>
 Creates a HashSetDelta using the given operations.
 Note that the values from the map are interpreted as reference-deltas and should therefore not be 0.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.ofArray``1(FSharp.Data.Adaptive.SetOperation{``0}[])">
<summary>
 Creates a HashSetDelta using the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{FSharp.Data.Adaptive.SetOperation{``0}})">
<summary>
 Creates a HashSetDelta using the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.ofSeq``1(System.Collections.Generic.IEnumerable{FSharp.Data.Adaptive.SetOperation{``0}})">
<summary>
 Creates a HashSetDelta using the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.single``1(FSharp.Data.Adaptive.SetOperation{``0})">
<summary>
 Creates a set from a single operation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.count``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 The number of operations contained in the HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.isEmpty``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Is the set empty?
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.inverse``1(FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 The inverse operations for the given set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashSetDeltaModule.empty``1">
<summary>
 The empty set.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.HashSetDeltaModule">
<summary>
 Functional operators for HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.combine``2(FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1},FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1})">
<summary>
 Combines two HashMapDeltas to one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.toHashMap``2(FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1})">
<summary>
 All deltas contained in the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.toArray``2(FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1})">
<summary>
 All deltas contained in the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.toList``2(FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1})">
<summary>
 All deltas contained in the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.toSeq``2(FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1})">
<summary>
 All deltas contained in the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.count``2(FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1})">
<summary>
 The number of deltas in the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.isEmpty``2(FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.ofArray``2(System.Tuple{``0,FSharp.Data.Adaptive.ElementOperation{``1}}[])">
<summary>
 A HashMapDelta containing all the given deltas.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.ofList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,FSharp.Data.Adaptive.ElementOperation{``1}}})">
<summary>
 A HashMapDelta containing all the given deltas.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,FSharp.Data.Adaptive.ElementOperation{``1}}})">
<summary>
 A HashMapDelta containing all the given deltas.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.ofHashMap``2(FSharp.Data.Adaptive.FSharpHashMap{``0,FSharp.Data.Adaptive.ElementOperation{``1}})">
<summary>
 A HashMapDelta containing all the given deltas.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.single``2(``0,FSharp.Data.Adaptive.ElementOperation{``1})">
<summary>
 A single map delta containing one operation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HashMapDelta.empty``2">
<summary>
 The empty map delta.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.HashMapDelta">
<summary>
 Functional operators for HashMapDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.collect``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{``0},FSharp.Data.Adaptive.IndexListDelta{``1}}},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Applies the mapping function to all elements and combines the resulting lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.combine``1(FSharp.Data.Adaptive.IndexListDelta{``0},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Combines to IndexListDeltas to one.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{``0},System.Boolean}},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Filters the delta list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{``0},Microsoft.FSharp.Core.FSharpOption{FSharp.Data.Adaptive.ElementOperation{``1}}}},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the &apos;Some&apos;-results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.map``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{``0},FSharp.Data.Adaptive.ElementOperation{``1}}},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.chooseIndexed``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{``0},Microsoft.FSharp.Core.FSharpOption{System.Tuple{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``1}}}}},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the &apos;Some&apos;-results.
 Note that the indices need to be monotonic.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.mapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.ElementOperation{``0},System.Tuple{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``1}}}},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Applies the given mapping function to all deltas in the list and returns a new list containing the &apos;Some&apos;-results.
 Note that the indices need to be monotonic.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.toArray``1(FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Returns all the operations contained in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.toList``1(FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Returns all the operations contained in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.toSeq``1(FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Returns all the operations contained in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.ofArray``1(System.Tuple{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0}}[])">
<summary>
 Creates an IndexListDelta containing all the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0}}})">
<summary>
 Creates an IndexListDelta containing all the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.ofSeq``1(System.Collections.Generic.IEnumerable{System.Tuple{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0}}})">
<summary>
 Creates an IndexListDelta containing all the given operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.single``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0})">
<summary>
 Creates a delta containing a single operation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.ofIndexList``1(FSharp.Data.Adaptive.IndexList{FSharp.Data.Adaptive.ElementOperation{``0}})">
<summary>
 Internal creating an IndexListDelta from the given list IndexList.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.ofMap``1(FSharp.Data.Adaptive.MapExt{FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0}})">
<summary>
 Internal creating an IndexListDelta from the given map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.remove``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Removes the operation associated to index. (if any)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.add``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.ElementOperation{``0},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Inserts an operation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.isEmpty``1(FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Is the list empty?
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.IndexListDeltaModule.empty``1">
<summary>
 The empty delta.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.IndexListDeltaModule">
<summary>
 Functional operators for IndexListDelta.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DifferentiationExtensions.IndexList.computeDelta``1(FSharp.Data.Adaptive.IndexList{``0},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Applies the given operations to the list. 
 Returns the new list and the &apos;effective&apos; operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DifferentiationExtensions.IndexList.applyDelta``1(FSharp.Data.Adaptive.IndexList{``0},FSharp.Data.Adaptive.IndexListDelta{``0})">
<summary>
 Determines the operations needed to transform l into r.
 Returns a IndexListDelta containing these operations.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.DifferentiationExtensions.IndexList">
<summary>
 Functional programming operators related to the IndexList&lt;_&gt; type.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DifferentiationExtensions.HashMap.computeDelta``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Determines the operations needed to transform l into r.
 Returns a HashMapDelta containing all the needed operations.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.DifferentiationExtensions.HashMap">
<summary>
 Functional programming operators related to the HashMap&lt;_,_&gt; type.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DifferentiationExtensions.HashSet.applyDelta``1(FSharp.Data.Adaptive.FSharpHashSet{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Applies the given operations to the set. 
 Returns the new set and the &apos;effective&apos; operations.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DifferentiationExtensions.HashSet.addAll``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Same as computeDelta empty set
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DifferentiationExtensions.HashSet.removeAll``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Same as computeDelta set empty
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.DifferentiationExtensions.HashSet.computeDelta``1(FSharp.Data.Adaptive.FSharpHashSet{``0},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Determines the operations needed to transform l into r.
 Returns a HashSetDelta containing these operations.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.DifferentiationExtensions.HashSet">
<summary>
 Functional programming operators related to the HashSet&lt;_&gt; type.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.DifferentiationExtensions">
<summary>
 Differentiation extensions for several immutable datastructures.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.MultiSetMap">
<summary>
 A simple multi-map implementation.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.RangeDelta.rangeChange``2(``0,``1,``0,``1)">
<summary>
 Determine the changes in a range of integers
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.InterlockedExtensions.Interlocked.Change.Static``1(Microsoft.FSharp.Core.byref{``0,Microsoft.FSharp.Core.ByRefKinds.InOut},Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Changes the byref by applying the given function in a thread-safe way. 
 NOTE that the function might be evaluated multiple times.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ReferenceEqualityOperators.op_BangEquals``1(``0,``0)">
<summary>
 Determines whether the given objects are not reference equal
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ReferenceEqualityOperators.op_EqualsEquals``1(``0,``0)">
<summary>
 Determines whether the given objects are reference equal
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ReferenceEqualityOperators.refequal``1(``0,``0)">
<summary>
 Determines whether the given objects are reference equal
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ReferenceEqualityOperators.refhash``1(``0)">
<summary>
 Gets a reference-hashcode
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HeapExtensions.List`1.HeapDequeue``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}})">
<summary>
 Dequeues the smallest element from the heap-order list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HeapExtensions.List`1.HeapDequeue``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``0,System.Int32})">
<summary>
 Dequeues the smallest element from the heap-order list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HeapExtensions.List`1.HeapEnqueue``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0)">
<summary>
 Enqueues an element to the list in heap-order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HeapExtensions.List`1.HeapEnqueue``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``0,System.Int32},``0)">
<summary>
 Enqueues an element  to the list in heap-order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HeapExtensions.pushDown``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``0,System.Int32},System.Int32,``0)">
<summary>
 Moves an element in the list &apos;down&apos; in heap-order.
 Assumes that the list is in heap-order except for the given element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HeapExtensions.bubbleUp``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``0,System.Int32},System.Int32,``0)">
<summary>
 Moves an element in the list &apos;up&apos; in heap-order.
 Assumes that the list is in heap-order except for the given element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.HeapExtensions.swap``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
 Swaps the given elements inside the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactQueueEntryHeap.pushDown``1(System.Collections.Generic.List{FSharp.Data.Adaptive.TransactQueueEntry{``0}},System.Int32,FSharp.Data.Adaptive.TransactQueueEntry{``0})">
<summary>
 Moves an element in the list &apos;down&apos; in heap-order.
 Assumes that the list is in heap-order except for the given element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactQueueEntryHeap.bubbleUp``1(System.Collections.Generic.List{FSharp.Data.Adaptive.TransactQueueEntry{``0}},System.Int32,FSharp.Data.Adaptive.TransactQueueEntry{``0})">
<summary>
 Moves an element in the list &apos;up&apos; in heap-order.
 Assumes that the list is in heap-order except for the given element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactQueueEntryHeap.swap``1(System.Collections.Generic.List{FSharp.Data.Adaptive.TransactQueueEntry{``0}},System.Int32,System.Int32)">
<summary>
 Swaps the given elements inside the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.WeakOutputSetModule.remove(FSharp.Data.Adaptive.IAdaptiveObject,FSharp.Data.Adaptive.WeakOutputSet)">
<summary>
 Removes the reference to the given AdaptiveObject from the set
 and returns a boolean indicating whether the obj was removed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.WeakOutputSetModule.add(FSharp.Data.Adaptive.IAdaptiveObject,FSharp.Data.Adaptive.WeakOutputSet)">
<summary>
 Adds a weak reference to the given AdaptiveObject to the set
 and returns a boolean indicating whether the obj was new.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.WeakOutputSetModule.create">
<summary>
 Creates a new empty WeakOutputSet
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.WeakOutputSetModule">
<summary>
 Supporting operations for the WeakOutputSet type.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactionModule.IAdaptiveObject.MarkOutdated(FSharp.Data.Adaptive.IAdaptiveObject,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Utility for marking adaptive object as outOfDate.
 Note that this function will actually enqueue the
 object to the current transaction and will fail if
 no current transaction can be found.
 However objects which are already outOfDate might
 Also be &quot;marked&quot; when not having a current transaction.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactionModule.IAdaptiveObject.MarkOutdated(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Utility for marking adaptive object as outOfDate.
 Note that this function will actually enqueue the
 object to the current transaction and will fail if
 no current transaction can be found.
 However objects which are already outOfDate might
 also be &quot;marked&quot; when not having a current transaction.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactionModule.transact``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Executes a function &quot;inside&quot; a newly created
 transaction and commits the transaction
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.TransactionModule.getCurrentTransaction">
<summary>
 Returns the currently running transaction or (if none)
 the current transaction for the calling thread
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.TransactionModule">
<summary>
 Module for transaction related functions. (e.g. transact)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.LockingExtensions.IAdaptiveObject.IsOutdatedCaller(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Determines whether the object is locked and out-of-date
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.LockingExtensions.IAdaptiveObject.ExitWrite(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Releases the write-lock to the AdaptiveObject
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.LockingExtensions.IAdaptiveObject.EnterWrite(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 Acquires a write-lock to an AdaptiveObject
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdadptiveObjectExtensions.AdaptiveObject.EvaluateIfNeeded``1(FSharp.Data.Adaptive.AdaptiveObject,FSharp.Data.Adaptive.AdaptiveToken,``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.AdaptiveToken,``0})">
<summary>
 Utility function for evaluating an object if it is marked as outOfDate.
 If the object is actually outOfDate the given function is executed and otherwise
 The given default value is returned. This method takes care of appropriate locking
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdadptiveObjectExtensions.AdaptiveObject.EvaluateAlways``1(FSharp.Data.Adaptive.AdaptiveObject,FSharp.Data.Adaptive.AdaptiveToken,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.AdaptiveToken,``0})">
<summary>
 Utility function for evaluating an object even if it is not marked as outOfDate.
 This method takes care of appropriate locking
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdadptiveObjectExtensions.AdaptiveObject.RunAfterEvaluate.Static(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Executes the given action after the (currently running) evaluation has finished (once).
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CallbackExtensions.IAdaptiveObject.OnWeakNextMarking(FSharp.Data.Adaptive.IAdaptiveObject,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Registers a callback with the given object that will be executed
 ONCE! when the next out-of-date marking visits the object.
 Note that it does not trigger when the object is currently out-of-date.
 Returns a disposable for removing the callback.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CallbackExtensions.IAdaptiveObject.OnNextMarking(FSharp.Data.Adaptive.IAdaptiveObject,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Registers a callback with the given object that will be executed
 ONCE! when the next out-of-date marking visits the object.
 Note that it does not trigger when the object is currently out-of-date.
 Returns a disposable for removing the callback.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CallbackExtensions.IAdaptiveObject.AddWeakMarkingCallback(FSharp.Data.Adaptive.IAdaptiveObject,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Registers a callback with the given object that will be executed
 whenever the object gets marked out-of-date.
 Note that it does not trigger when the object is currently out-of-date.
 Returns a disposable for removing the callback.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CallbackExtensions.IAdaptiveObject.AddMarkingCallback(FSharp.Data.Adaptive.IAdaptiveObject,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Registers a callback with the given object that will be executed
 whenever the object gets marked out-of-date.
 Note that it does not trigger when the object is currently out-of-date.
 Returns a disposable for removing the callback.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CallbackExtensions.IAdaptiveObject.AddMarkingCallback(FSharp.Data.Adaptive.IAdaptiveObject,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Registers a callback with the given object that will be executed
 whenever the object gets marked out-of-date.
 Note that it does not trigger when the object is currently out-of-date.
 Returns a disposable for removing the callback.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CallbackExtensions.getMultiCallback(FSharp.Data.Adaptive.IAdaptiveObject)">
<summary>
 utility getting/creating a MultiCallbackObjects for the given IAdaptiveObject  
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.CallbackExtensions.callbackObjects">
<summary>
 cache for MultiCallbackObjects per IAdaptiveObject
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CallbackExtensions">
<summary>
 IAdaptiveObject extensions for creating/removing callbacks.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.custom``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.AdaptiveToken,``0})">
<summary>
 Creates a custom adaptive value using the given computation.
 Callers are responsible for removing inputs that are no longer needed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.bind3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,FSharp.Data.Adaptive.IAdaptiveValue{``3}}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1},FSharp.Data.Adaptive.IAdaptiveValue{``2})">
<summary>
 Adaptively applies the mapping function to the given adaptive values and
 adaptively depends on the adaptive value returned by mapping.
 The resulting aval&lt;&apos;T4&gt; will hold the latest value of the aval&lt;_&gt; returned by mapping.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.bind2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{``2}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1})">
<summary>
 Adaptively applies the mapping function to the given adaptive values and
 adaptively depends on the adaptive value returned by mapping.
 The resulting aval&lt;&apos;T3&gt; will hold the latest value of the aval&lt;_&gt; returned by mapping.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}},FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Returns a new adaptive value that adaptively applies the mapping function to the given 
 input and adaptively depends on the resulting adaptive value.
 The resulting adaptive value  will hold the latest value of the aval&lt;_&gt; returned by mapping.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1},FSharp.Data.Adaptive.IAdaptiveValue{``2})">
<summary>
 Returns a new adaptive value that adaptively applies the mapping function to the given 
 adaptive inputs.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1})">
<summary>
 Returns a new adaptive value that adaptively applies the mapping function to the given 
 adaptive inputs.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Returns a new adaptive value that adaptively applies the mapping function to the given 
 adaptive inputs.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a constant adaptive value using the given create function.
 The system internally propagates constants.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.constant``1(``0)">
<summary>
 Creates a constant adaptive value always holding the given value.
 The system internally propagates constants.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.init``1(``0)">
<summary>
 Creates a changeable adaptive value intially holding the given value
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AValModule.force``1(FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Evaluates the given adaptive value and returns its current value.
 This should not be used inside the adaptive evaluation
 of other AdaptiveObjects since it does not track dependencies.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.AValModule">
<summary>
 Operators related to the aval&lt;_&gt; type 
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.average``2">
<summary>
 A reduction returning the average of all elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.product``2">
<summary>
 A reduction returning the product of all elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.sum``2">
<summary>
 A reduction returning the sum of all elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.tryMax``1">
<summary>
 A reduction getting the largest element (if any)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.tryMin``1">
<summary>
 A reduction getting the smallest element (if any)
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveReduction.countNegative">
<summary>
 A simple reduction counting all elements that are false.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.AdaptiveReduction.countPositive">
<summary>
 A simple reduction counting all elements that are true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.count``1">
<summary>
 A simple reduction counting all elements.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.fold``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}})">
<summary>
 Creates a new AdaptiveReduction using the given *classical* fold function.
 Note the these *classical* folds are inefficient in presence of adaptivity and 
 should be replaced by *group-like* constructs whenever possible.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.halfGroup``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpValueOption{``0}}})">
<summary>
 Creates a new AdaptiveReduction using the given (partial-group-like) functions.
 Note that the functions need to fulfill the following laws when sub claims success (and maybe more)
 * `sub (add x a) a = x` (inverse)
 * `add (sub x a) a = x` (inverse)
 * `add (add x a) b = add (add x b) a` (commutativity)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.group``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}})">
<summary>
 Creates a new AdaptiveReduction using the given (group-like) functions.
 Note that the functions need to fulfill the following laws (and maybe more)
 * `sub (add x a) a = x` (inverse)
 * `add (sub x a) a = x` (inverse)
 * `add (add x a) b = add (add x b) a` (commutativity)
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.mapOut``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.AdaptiveReduction{``2,``3,``0})">
<summary>
 Applies a mapping function on the output side of the given AdaptiveReduction.
 Note that the supplied mapping function is assumed to be very cheap.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.mapIn``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.AdaptiveReduction{``1,``2,``3})">
<summary>
 Applies a mapping function on the input side of the given AdaptiveReduction.
 Note that the supplied mapping function is assumed to be very cheap.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.structpar``5(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},FSharp.Data.Adaptive.AdaptiveReduction{``0,``3,``4})">
<summary>
 Creates a new AdaptiveReduction that simultaniously (parallel) applies two
 reductions by (struct) tupling the state- and result-type.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AdaptiveReduction.par``5(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},FSharp.Data.Adaptive.AdaptiveReduction{``0,``3,``4})">
<summary>
 Creates a new AdaptiveReduction that simultaniously (parallel) applies two
 reductions by tupling the state- and result-type.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.AdaptiveReduction">
<summary>
 Functional operators for AdaptiveReduction.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.averageByA``3(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively computes the average of all values returned by mapping for the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.sumByA``3(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively computes the sum of all values returned by mapping for the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.countByA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively counts all elements fulfilling the predicate
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.countBy``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively counts all elements fulfilling the predicate
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.existsA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively checks whether the predicate holds for at least one entry.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.forallA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively checks whether the predicate holds for all entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.averageBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively computes the average of all values returned by mapping for the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.sumBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively computes the sum of all values returned by mapping for the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.average``2(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively computes the average of all entries in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.sum``2(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively computes the sum of all entries in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.tryMax``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively tries to find the largest element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.tryMin``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively tries to find the smallest element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.contains``1(``0,FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively checks whether the aset contains the given entry.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively checks whether the predicate holds for at least one entry.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively checks whether the predicate holds for all entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Data.Adaptive.IAdaptiveHashSet{``1})">
<summary>
 Adaptively folds over the set using add for additions and recomputes the value on every removal.
 Note that the order of elements given to add is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.foldGroup``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Data.Adaptive.IAdaptiveHashSet{``1})">
<summary>
 Adaptively folds over the set using add for additions and subtract for removals.
 Note that the order of elements given to add/subtract is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.foldHalfGroup``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,FSharp.Data.Adaptive.IAdaptiveHashSet{``1})">
<summary>
 Adaptively folds over the set using add for additions and trySubtract for removals.
 Note the trySubtract may return None indicating that the result needs to be recomputed.
 Also note that the order of elements given to add/trySubtract is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.reduceByA``4(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,FSharp.Data.Adaptive.IAdaptiveValue{``0}},FSharp.Data.Adaptive.IAdaptiveHashSet{``3})">
<summary>
 Applies the mapping function to all elements of the set and reduces the results
 using the given `AdaptiveReduction`.
 Returns the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.reduceBy``4(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,``0},FSharp.Data.Adaptive.IAdaptiveHashSet{``3})">
<summary>
 Applies the mapping function to all elements of the set and reduces the results
 using the given `AdaptiveReduction`.
 Returns the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.reduce``3(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Reduces the set using the given `AdaptiveReduction` and returns
 the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.count``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively gets the number of elements in the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.isEmpty``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively tests if the set is empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.force``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Evaluates the given adaptive set and returns its current content.
 This should not be used inside the adaptive evaluation
 of other AdaptiveObjects since it does not track dependencies.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Data.Adaptive.FSharpHashSet{``0}})">
<summary>
 Creates a constant aset lazy content.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.custom``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.AdaptiveToken,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0}}})">
<summary>
 Creates an aset using the given compute function
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.ofReader``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates an aset using the given reader-creator.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.filterA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively filters the set and also respects inner changes.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.chooseA``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{Microsoft.FSharp.Core.FSharpOption{``1}}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively maps over the set and also respects inner changes.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.mapA``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively maps over the set and also respects inner changes.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.flattenA``1(FSharp.Data.Adaptive.IAdaptiveHashSet{FSharp.Data.Adaptive.IAdaptiveValue{``0}})">
<summary>
 Adaptively flattens the set of adaptive refs.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.mapUse``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively maps over the given set and disposes all removed values while active.
 Additionally the returned Disposable disposes all currently existing values and clears the resulting set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.bind3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,FSharp.Data.Adaptive.IAdaptiveHashSet{``3}}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1},FSharp.Data.Adaptive.IAdaptiveValue{``2})">
<summary>
 Adaptively maps over the given avals and returns the resulting set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.bind2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveHashSet{``2}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1})">
<summary>
 Adaptively maps over the given avals and returns the resulting set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveHashSet{``1}},FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Adaptively maps over the given aval and returns the resulting set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.ofAVal``2(FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Creates an aset for the given aval.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.collect'``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Collections.Generic.IEnumerable{``1}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively maps over the given set and unions all resulting seqs.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveHashSet{``1}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively maps over the given set and unions all resulting sets.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.intersect``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively intersects the given sets
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.unionMany``1(FSharp.Data.Adaptive.IAdaptiveHashSet{FSharp.Data.Adaptive.IAdaptiveHashSet{``0}})">
<summary>
 Adaptively unions all the given sets
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.union``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively unions the given sets
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively filters the set using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively chooses all elements returned by mapping.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Adaptively maps over the given set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.range``1(FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Generate an adaptive range of items based on lower/upper bound
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.toAVal``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Creates an aval providing access to the current content of the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.ofHashSet``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates an aset holding the given values. `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.ofArray``1(``0[])">
<summary>
 Creates an aset holding the given values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates an aset holding the given values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an aset holding the given values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.single``1(``0)">
<summary>
 A constant aset holding a single value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.constant``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Data.Adaptive.FSharpHashSet{``0}})">
<summary>
 Creates an aset using the given set generator
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.ASetModule.empty``1">
<summary>
 The empty aset.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ASetModule">
<summary>
 Functional operators for aset&lt;_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.averageByA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{``2}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively computes the average of all values returned by mapping for the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.sumByA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{``2}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively computes the sum of all values returned by mapping for the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.countByA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively counts all elements fulfilling the predicate
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.countBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively counts all elements fulfilling the predicate
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.existsA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively checks whether the predicate holds for at least one entry.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.forallA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively checks whether the predicate holds for all entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.averageBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively computes the average of all values returned by mapping for the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.sumBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively computes the sum of all values returned by mapping for the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively checks whether the predicate holds for at least one entry.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively checks whether the predicate holds for all entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,FSharp.Data.Adaptive.IAdaptiveHashMap{``1,``2})">
<summary>
 Adaptively folds over the map using add for additions and recomputes the value on every removal.
 Note that the order of elements given to add is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.foldGroup``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,FSharp.Data.Adaptive.IAdaptiveHashMap{``1,``2})">
<summary>
 Adaptively folds over the map using add for additions and subtract for removals.
 Note that the order of elements given to add/subtract is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.foldHalfGroup``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpOption{``0}}}},``0,FSharp.Data.Adaptive.IAdaptiveHashMap{``1,``2})">
<summary>
 Adaptively folds over the map using add for additions and trySubtract for removals.
 Note the trySubtract may return None indicating that the result needs to be recomputed.
 Also note that the order of elements given to add/trySubtract is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.reduceByA``5(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,FSharp.Data.Adaptive.IAdaptiveValue{``0}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``3,``4})">
<summary>
 Applies the mapping function to all elements of the map and reduces the results
 using the given `AdaptiveReduction`.
 Returns the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.reduceBy``5(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,``0}},FSharp.Data.Adaptive.IAdaptiveHashMap{``3,``4})">
<summary>
 Applies the mapping function to all elements of the map and reduces the results
 using the given `AdaptiveReduction`.
 Returns the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.reduce``4(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},FSharp.Data.Adaptive.IAdaptiveHashMap{``3,``0})">
<summary>
 Reduces the map using the given `AdaptiveReduction` and returns
 the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.count``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively gets the number of elements in the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.isEmpty``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively tests if the map is empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.force``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Evaluates the given adaptive map and returns its current content.
 This should not be used inside the adaptive evaluation
 of other AdaptiveObjects since it does not track dependencies.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.find``2(``0,FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively looks up the given key in the map.
 Note that this operation should not be used extensively since its resulting
 aval will be re-evaluated upon every change of the map.
 WARNING: causes KeyNotFoundException when the key is not present at evaluation-time
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.tryFind``2(``0,FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively looks up the given key in the map.
 Note that this operation should not be used extensively since its resulting
 aval will be re-evaluated upon every change of the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.toASetValues``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Creates an aset holding all distinct values from the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.toASet``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Creates an aset holding all key/value tuples from the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.mapUse``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively maps over the given map and disposes all removed values while active.
 Additionally the returned Disposable disposes all currently existing values and clears the resulting map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.bind3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,FSharp.Data.Adaptive.IAdaptiveHashMap{``3,``4}}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1},FSharp.Data.Adaptive.IAdaptiveValue{``2})">
<summary>
 Adaptively maps over the given avals and returns the resulting map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.bind2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveHashMap{``2,``3}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1})">
<summary>
 Adaptively maps over the given avals and returns the resulting map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveHashMap{``1,``2}},FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Adaptively maps over the given aval and returns the resulting map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.union``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively unions both maps preferring the right value when colliding entries are found.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.unionWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively unions both maps using the given resolve functions when colliding entries are found.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.filterA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.chooseA``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{Microsoft.FSharp.Core.FSharpOption{``2}}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively chooses all elements returned by mapping.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.mapA``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{``2}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new amap containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.filter'``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveHashMap{``1,``0})">
<summary>
 Adaptively filters the set using the given predicate without exposing keys.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively filters the set using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.choose'``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FSharp.Data.Adaptive.IAdaptiveHashMap{``2,``0})">
<summary>
 Adaptively chooses all elements returned by mapping without exposing keys.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively chooses all elements returned by mapping.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.map'``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashMap{``2,``0})">
<summary>
 Adaptively maps over the given map without exposing keys.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.mapSet``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Creates an amap with the keys from the set and the values given by mapping.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Adaptively maps over the given map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.toAVal``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Creates an aval providing access to the current content of the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.custom``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.AdaptiveToken,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.FSharpHashMap{``0,``1},FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1}}})">
<summary>
 Creates an amap using the given compute function
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofReader``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates an amap using the given reader-creator.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofASetIgnoreDuplicates``2(FSharp.Data.Adaptive.IAdaptiveHashSet{System.Tuple{``0,``1}})">
<summary>
 Creates an amap from the given set and takes an arbitrary value for duplicate entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofASet``2(FSharp.Data.Adaptive.IAdaptiveHashSet{System.Tuple{``0,``1}})">
<summary>
 Creates an amap from the given set while keeping all duplicate values for a key in a HashSet.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofAVal``3(FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Creates an amap for the given aval.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofHashMap``2(FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Creates an amap holding the given entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofArray``2(System.Tuple{``0,``1}[])">
<summary>
 Creates an amap holding the given entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Creates an amap holding the given entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Creates an amap holding the given entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.single``2(``0,``1)">
<summary>
 A constant amap holding a single key/value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AMapModule.empty``2">
<summary>
 The empty map.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.AMapModule">
<summary>
 Functional operators for amap&lt;_,_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.averageByA``3(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively computes the average of all values returned by mapping for the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sumByA``3(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively computes the sum of all values returned by mapping for the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.countByA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively counts all elements fulfilling the predicate
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.countBy``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively counts all elements fulfilling the predicate
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.existsA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively checks whether the predicate holds for at least one entry.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.forallA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively checks whether the predicate holds for all entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.averageBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively computes the average of all values returned by mapping for the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sumBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively computes the sum of all values returned by mapping for the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.average``2(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively computes the average of all entries in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sum``2(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively computes the sum of all entries in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.tryMax``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively tries to find the largest element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.tryMin``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively tries to find the smallest element.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively checks whether the predicate holds for at least one entry.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively checks whether the predicate holds for all entries.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Data.Adaptive.IAdaptiveIndexList{``1})">
<summary>
 Adaptively folds over the list using add for additions and recomputes the value on every removal.
 Note that the order of elements given to add is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.foldGroup``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Data.Adaptive.IAdaptiveIndexList{``1})">
<summary>
 Adaptively folds over the list using add for additions and subtract for removals.
 Note that the order of elements given to add/subtract is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.foldHalfGroup``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,FSharp.Data.Adaptive.IAdaptiveIndexList{``1})">
<summary>
 Adaptively folds over the list using add for additions and trySubtract for removals.
 Note the trySubtract may return None indicating that the result needs to be recomputed.
 Also note that the order of elements given to add/trySubtract is undefined.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.reduceByA``4(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``3,FSharp.Data.Adaptive.IAdaptiveValue{``0}}},FSharp.Data.Adaptive.IAdaptiveIndexList{``3})">
<summary>
 Applies the mapping function to all elements of the list and reduces the results
 using the given `AdaptiveReduction`.
 Returns the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.reduceBy``4(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``3,``0}},FSharp.Data.Adaptive.IAdaptiveIndexList{``3})">
<summary>
 Applies the mapping function to all elements of the list and reduces the results
 using the given `AdaptiveReduction`.
 Returns the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.reduce``3(FSharp.Data.Adaptive.AdaptiveReduction{``0,``1,``2},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Reduces the list using the given `AdaptiveReduction` and returns
 the resulting adaptive value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.force``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Evaluates the given adaptive list and returns its current content.
 This should not be used inside the adaptive evaluation
 of other AdaptiveObjects since it does not track dependencies.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.count``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively gets the number of elements in the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.isEmpty``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively tests if the list is empty.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.tryLast``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Tries to get the last element from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.tryFirst``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Tries to get the first element from the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.tryAt``1(System.Int32,FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Tries to get the element at a specific position from the list.
 Note that this operation should not be used extensively since its resulting
 aval will be re-evaluated upon every change of the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.tryGet``1(FSharp.Data.Adaptive.Index,FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Tries to get the element associated to a specific Index from the list.
 Note that this operation should not be used extensively since its resulting
 aval will be re-evaluated upon every change of the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.pairwiseCyclic``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Returns a list of each element tupled with its successor and the last element tupled with the first.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.pairwise``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Returns a list containing all elements tupled with their successor.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sortDescending``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Sorts the list in descending order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sort``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Sorts the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Sorts the list using the given compare function.
 Note that the sorting is stable.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Sorts the list using the keys given by projection in descending order.
 Note that the sorting is stable.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Sorts the list using the keys given by projection.
 Note that the sorting is stable.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sortByDescendingi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Sorts the list using the keys given by projection in descending order.
 Note that the sorting is stable.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.sortByi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Sorts the list using the keys given by projection.
 Note that the sorting is stable.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.mapUse``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively maps over the given list and disposes all removed values while active.
 Additionally the returned Disposable disposes all currently existing values and clears the resulting list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.mapUsei``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively maps over the given list and disposes all removed values while active.
 Additionally the returned Disposable disposes all currently existing values and clears the resulting list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.bind3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,FSharp.Data.Adaptive.IAdaptiveIndexList{``3}}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1},FSharp.Data.Adaptive.IAdaptiveValue{``2})">
<summary>
 Adaptively maps over the given avals and returns the resulting list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.bind2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveIndexList{``2}}},FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``1})">
<summary>
 Adaptively maps over the given avals and returns the resulting list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveIndexList{``1}},FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Adaptively maps over the given aval and returns the resulting list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.ofAVal``2(FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Creates an alist from the given adaptive content
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.toAVal``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Creates an aval providing access to the current content of the list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.append``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively concatenates the given lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.concat``2(``0)">
<summary>
 Adaptively concatenates the given lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.rev``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively reverses the list
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.indexed``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively creates an alist with the source-indices.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.collect'``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Collections.Generic.IEnumerable{``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new alist holding the concatenated results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveIndexList{``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new alist holding the concatenated results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.collecti``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveIndexList{``1}}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new alist holding the concatenated results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.filterA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.filterAi``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.chooseA``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{Microsoft.FSharp.Core.FSharpOption{``1}}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively chooses all elements returned by mapping.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.chooseAi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{Microsoft.FSharp.Core.FSharpOption{``1}}}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively chooses all elements returned by mapping.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.mapA``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new alist containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.mapAi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{``1}}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new alist containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.filteri``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively filters the list using the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively chooses all elements returned by mapping.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.choosei``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively chooses all elements returned by mapping.  
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new alist containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.Index,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Adaptively applies the given mapping function to all elements and returns a new alist containing the results.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.range``1(FSharp.Data.Adaptive.IAdaptiveValue{``0},FSharp.Data.Adaptive.IAdaptiveValue{``0})">
<summary>
 Generate an adaptive range of items based on lower/upper bound
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.init``1(FSharp.Data.Adaptive.IAdaptiveValue{System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Generate a list of adaptive length using the given intializer
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.constant``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Data.Adaptive.IndexList{``0}})">
<summary>
 Creates an alist using the given value generator
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.custom``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.AdaptiveToken,Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.IndexList{``0},FSharp.Data.Adaptive.IndexListDelta{``0}}})">
<summary>
 Creates an alist using the given compute function
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.ofReader``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates an alist using the given reader-creator.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.ofIndexList``1(FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Creates an alist holding the given values. `O(1)`
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.ofArray``1(``0[])">
<summary>
 Creates an alist holding the given values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates an alist holding the given values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an alist holding the given values.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.single``1(``0)">
<summary>
 A constant alist holding a single value.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.AListModule.empty``1">
<summary>
 The empty alist.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.AListModule">
<summary>
 Functional operators for the alist&lt;_&gt; type.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.IndexList.forallA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Adaptively checks whether all entries make the given predicate true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.IndexList.existsA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.IndexList{``0})">
<summary>
 Adaptively checks whether one or more entries make the given predicate true.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.IndexList">
<summary>
 Adaptive operators for IndexList.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.Map.forallA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Adaptively checks whether all entries make the given predicate true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.Map.existsA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Adaptively checks whether one or more entries make the given predicate true.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Map">
<summary>
 Adaptive operators for Map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.HashMap.forallA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Adaptively checks whether all entries make the given predicate true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.HashMap.existsA``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}}},FSharp.Data.Adaptive.FSharpHashMap{``0,``1})">
<summary>
 Adaptively checks whether one or more entries make the given predicate true.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.HashMap">
<summary>
 Adaptive operators for HashMap.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.HashSet.forallA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Adaptively checks whether all entries make the given predicate true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.HashSet.existsA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Adaptively checks whether one or more entries make the given predicate true.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.HashSet">
<summary>
 Adaptive operators for HashSet.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.Array.forallA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},``0[])">
<summary>
 Adaptively checks whether all entries make the given predicate true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.Array.existsA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},``0[])">
<summary>
 Adaptively checks whether one or more entries make the given predicate true.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Array">
<summary>
 Adaptive operators for arrays.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.Seq.forallA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Adaptively checks whether all entries make the given predicate true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.Seq.existsA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Adaptively checks whether one or more entries make the given predicate true.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Seq">
<summary>
 Adaptive operators for seq.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.List.forallA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Adaptively checks whether all entries make the given predicate true.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.List.existsA``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Adaptive.IAdaptiveValue{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Adaptively checks whether one or more entries make the given predicate true.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.List">
<summary>
 Adaptive operators for lists.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AListModule.groupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Groups the alist by the given mapping and returns an amap with potentially colliding entries in a IndexList&lt;&apos;T&gt;.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AListModule.ofAMap``1(FSharp.Data.Adaptive.IAdaptiveHashMap{FSharp.Data.Adaptive.Index,``0})">
<summary>
 Creates an alist using the given amap&lt;Index, &apos;T&gt;.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AListModule.toAMap``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Creates an amap using the given alist.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AListModule.ofASet``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Creates an alist from the set with undefined element order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AListModule.toASetIndexed``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Creates an aset holding all index/elements pairs of the given list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AListModule.toASet``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Creates an aset holding all elements of the given list.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.AListModule">
<summary>
 Functional operators for alist&lt;_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.groupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Groups the aset by the given mapping and returns an amap with potentially colliding entries in a HashSet&lt;&apos;T&gt;.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.toAList``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Creates an alist from the set with undefined element order.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.sort``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Sorts the set.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Sorts the set using the keys given by projection.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.sortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Sorts the set using the given compare function.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.mapToAMap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Adaptive.IAdaptiveHashSet{``0})">
<summary>
 Creates an amap with the keys from the set and the values given by mapping.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.ofAListIndexed``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Creates an aset holding all index/elements pairs of the given list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.ofAList``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Creates an aset holding all elements of the given list.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.ofAMapValues``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Creates an aset holding all distinct values from the map.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.ASetModule.ofAMap``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Creates an aset holding all key/value tuples from the map.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.ASetModule">
<summary>
 Functional operators for aset&lt;_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AMapModule.ofAList``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0})">
<summary>
 Creates an amap using the given alist.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AMapModule.toAList``1(FSharp.Data.Adaptive.IAdaptiveHashMap{FSharp.Data.Adaptive.Index,``0})">
<summary>
 Creates an alist using the given amap&lt;Index, &apos;T&gt;.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.CollectionExtensions.AMapModule.keys``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1})">
<summary>
 Gets the keys of the given map as aset&lt;_&gt;.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.AMapModule">
<summary>
 Functional operators for amap&lt;_,_&gt;
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Readers.ToListReader`1">
<summary>
 Reader for AList.ofASet
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Readers.IndexedListSetReader`1">
<summary>
 Reader for AList.toIndexedASet
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Readers.ListSetReader`1">
<summary>
 Reader for AList.toASet
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Readers.MapKeysReader`2">
<summary>
 Reader for AMap.keys
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Readers.SetSortWithReader`1">
<summary>
 Reader for ASet.sortWith
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions.Readers.SetSortByReader`2">
<summary>
 Reader for ASet.sortBy
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.CollectionExtensions">
<summary>
 Collection extensions for aset&lt;_&gt;, amap&lt;_,_&gt;, alist&lt;_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveIndexList`1.AddWeakCallback``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.IndexList{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.IndexListDelta{``0},Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the alist that will be executed whenever
 changes happen to the alist. The given action will be called with the
 alists state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveIndexList`1.AddCallback``1(FSharp.Data.Adaptive.IAdaptiveIndexList{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.IndexList{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.IndexListDelta{``0},Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the alist that will be executed whenever
 changes happen to the alist. The given action will be called with the
 alists state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveHashMap`2.AddWeakCallback``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.FSharpHashMap{``0,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1},Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the amap that will be executed whenever
 changes happen to the amap. The given action will be called with the
 amaps state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveHashMap`2.AddCallback``2(FSharp.Data.Adaptive.IAdaptiveHashMap{``0,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.FSharpHashMap{``0,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.FSharpHashMapDelta{``0,``1},Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the amap that will be executed whenever
 changes happen to the amap. The given action will be called with the
 amaps state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveHashSet`1.AddWeakCallback``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Traceable.CountingHashSet{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.FSharpHashSetDelta{``0},Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the aset that will be executed whenever
 changes happen to the aset. The given action will be called with the
 asets state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveHashSet`1.AddCallback``1(FSharp.Data.Adaptive.IAdaptiveHashSet{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Traceable.CountingHashSet{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Data.Adaptive.FSharpHashSetDelta{``0},Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the aset that will be executed whenever
 changes happen to the aset. The given action will be called with the
 asets state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IOpReader`2.AddWeakCallback``2(FSharp.Data.Traceable.IOpReader{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the reader that will be executed whenever
 changes exist on the reader. The given action will be called with the
 readers state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IOpReader`2.AddCallback``2(FSharp.Data.Traceable.IOpReader{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the reader that will be executed whenever
 changes exist on the reader. The given action will be called with the
 readers state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IOpReader`2.AddCallback``2(FSharp.Data.Traceable.IOpReader{``0,``1},System.Boolean,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Adds a disposable callback to the reader that will be executed whenever
 changes exist on the reader. The given action will be called with the
 readers state prior to the change and all changes applied to that state.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveValue`1.AddWeakCallback``1(FSharp.Data.Adaptive.IAdaptiveValue{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Adds a disposable callback to the aval that will be executed whenever the
 avals value changed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveValue`1.AddCallback``1(FSharp.Data.Adaptive.IAdaptiveValue{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Adds a disposable callback to the aval that will be executed whenever the
 avals value changed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveValue`1.AddCallback``1(FSharp.Data.Adaptive.IAdaptiveValue{``0},System.Boolean,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Adds a disposable callback to the aval that will be executed whenever the
 avals value changed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveValue.AddWeakCallback(FSharp.Data.Adaptive.IAdaptiveValue,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 Adds a disposable callback to the aval that will be executed whenever the
 avals value changed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveValue.AddCallback(FSharp.Data.Adaptive.IAdaptiveValue,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 Adds a disposable callback to the aval that will be executed whenever the
 avals value changed.
</summary>
</member>
<member name="M:FSharp.Data.Adaptive.EvaluationCallbackExtensions.IAdaptiveValue.AddCallback(FSharp.Data.Adaptive.IAdaptiveValue,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit})">
<summary>
 Adds a disposable callback to the aval that will be executed whenever the
 avals value changed.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.EvaluationCallbackExtensions">
<summary>
 Callback Extensions for adaptive datatypes.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ComputationExpressions.AMapBuilder">
<summary>
 ComputationExpression builder for amap.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ComputationExpressions.AListBuilder">
<summary>
 ComputationExpression builder for alist.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ComputationExpressions.ASetBuilder">
<summary>
 ComputationExpression builder for aset.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ComputationExpressions.AValBuilder">
<summary>
 ComputationExpression builder for aval.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ComputationExpressions.adaptive">
<summary>
 ComputationExpression builder for aval.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ComputationExpressions.amap">
<summary>
 ComputationExpression builder for amap.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ComputationExpressions.alist">
<summary>
 ComputationExpression builder for alist.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ComputationExpressions.aset">
<summary>
 ComputationExpression builder for aset.
</summary>
</member>
<member name="P:FSharp.Data.Adaptive.ComputationExpressions.aval">
<summary>
 ComputationExpression builder for aval.
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ComputationExpressions.Test">
<summary>
 tests if some ComputationExpressions compile
</summary>
</member>
<member name="T:FSharp.Data.Adaptive.ComputationExpressions">
<summary>
 ComputationExpression builders for aval/aset/alist/amap.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.AbstractVal`1">
<summary>
 Base class for standard avals
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Traceable`2.tprune">
<summary>
 Determines whether or not a history should be pruned although it is still referentiable.
 The first argument is the base-state for that history and the second argument is the size of the operaton that would need to be applied.
 When returning true the history implementation will discard the history and reproduce it on demand using tcomputeDelta.
 WARNING: current implementation is quite costly.
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Traceable`2.tsize">
<summary>
 Determines the size of an operation
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Traceable`2.tcomputeDelta">
<summary>
 Differentiates two states and returns the needed ops
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Traceable`2.tapplyDelta">
<summary>
 Applies the given operations to the state and 
 Returns the new state accompanied by (possibly) reduced ops (removing useless ops)
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Traceable`2.tempty">
<summary>
 The empty state
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Traceable`2.tmonoid">
<summary>
 The monoid instance for &apos;Delta
</summary>
</member>
<member name="T:FSharp.Data.Traceable.Traceable`2">
<summary>
 Function table for a traceable instance
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Monoid`1.mappend">
<summary>
 Appends to values
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Monoid`1.mempty">
<summary>
 The empty element
</summary>
</member>
<member name="P:FSharp.Data.Traceable.Monoid`1.misEmpty">
<summary>
 Determines whether the given value is empty
</summary>
</member>
<member name="T:FSharp.Data.Traceable.Monoid`1">
<summary>
 Function table for a monoid instance
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HistoryReader`4">
<summary>
 HistoryReader implements IOpReader&lt;_,_&gt; and takes care of managing versions correctly.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HistoryReader`2">
<summary>
 HistoryReader implements IOpReader&lt;_,_&gt; and takes care of managing versions correctly.
</summary>
</member>
<member name="F:FSharp.Data.Traceable.History`2.last">
<summary>
 The (weak) latest version known in the history
</summary>
</member>
<member name="F:FSharp.Data.Traceable.History`2.state">
<summary>
 The current state of the History
</summary>
</member>
<member name="P:FSharp.Data.Traceable.History`2.Trace">
<summary>
 The traceable instance used by the history
</summary>
</member>
<member name="P:FSharp.Data.Traceable.History`2.State">
<summary>
 The current state of the history
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.Update(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Used internally to pull the latest deltas from the input and append them to the history
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.Read(FSharp.Data.Adaptive.AdaptiveToken,FSharp.Data.Traceable.RelevantNode{`0,`1},`0)">
<summary>
 Used by HistoryReader to pull the operations since the old RelevantNode.
 Additionaly the reader provides its latest state. 
 This way the history can computeDelta the state in case it decided to drop the old version.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.PerformUnsafe(`0,`1)">
<summary>
 Imperatively performs operations on the history (similar to ModRef.Value &lt;- ...)
 and assumes that newState represents the current history-state with the given operations applied. (hence the Unsafe suffix)
 Since the history may need to be marked a Transaction needs to be current.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.Perform(`1)">
<summary>
 Imperatively performs operations on the history (similar to ModRef.Value &lt;- ...).
 Since the history may need to be marked a Transaction needs to be current.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.NewReader``2(FSharp.Data.Traceable.Traceable{``0,``1},Microsoft.FSharp.Core.FSharpFunc{`1,``1})">
<summary>
 Creates a new reader on the history
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.NewReader``2(FSharp.Data.Traceable.Traceable{``0,``1},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``1}})">
<summary>
 Creates a new reader on the history
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.NewReader">
<summary>
 Creates a new reader on the history
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History`2.GetValue(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Adaptively gets the history&apos;State current state
</summary>
</member>
<member name="T:FSharp.Data.Traceable.History`2">
<summary>
 History and HistoryReader are the central implementation for traceable data-types.
 The allow to construct a dependent History (by passing an input-reader) or imperatively
 performing operations on the history while keeping track of all output-versions that may exist.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.RelevantNode`2">
<summary>
 Linked list node used by the system to represent a &apos;version&apos; in the History
</summary>
</member>
<member name="M:FSharp.Data.Traceable.AbstractDirtyReader`2.GetChanges(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Adaptively get the latest deltas (or empty if up-to-date).
</summary>
</member>
<member name="M:FSharp.Data.Traceable.AbstractDirtyReader`2.Compute(FSharp.Data.Adaptive.AdaptiveToken,System.Collections.Generic.HashSet{`0})">
<summary>
 Adaptively compute deltas.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.AbstractDirtyReader`2.Apply(`1)">
<summary>
 Applies the delta to the current state and returns the &apos;effective&apos; delta.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.AbstractDirtyReader`2">
<summary>
 Abstract base class for implementing IOpReader&lt;_&gt; when dirty inputs are needed on evaluation.
</summary>
</member>
<member name="P:FSharp.Data.Traceable.AbstractReader`2.State">
<summary>
 The reader&apos;s current content.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.AbstractReader`2.Apply(`1)">
<summary>
 Applies the delta to the current state and returns the &apos;effective&apos; delta.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.AbstractReader`2">
<summary>
 Abstract base class for implementing IOpReader&lt;_,_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Traceable.AbstractReader`1.GetChanges(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Adaptively get the latest deltas (or empty if up-to-date).
</summary>
</member>
<member name="M:FSharp.Data.Traceable.AbstractReader`1.Compute(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Adaptively compute deltas.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.AbstractReader`1.Apply(`0)">
<summary>
 Applies the delta to the current state and returns the &apos;effective&apos; delta.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.AbstractReader`1">
<summary>
 Abstract base class for implementing IOpReader&lt;_&gt;
</summary>
</member>
<member name="P:FSharp.Data.Traceable.IOpReader`2.Trace">
<summary>
 The Traceable instance for the reader.
</summary>
</member>
<member name="P:FSharp.Data.Traceable.IOpReader`2.State">
<summary>
 The latest state of the Reader.
 Note that the state gets updated after each evaluation (GetChanges)
</summary>
</member>
<member name="T:FSharp.Data.Traceable.IOpReader`2">
<summary>
 An adaptive reader thath allows to get operations and also exposes its current state.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.IOpReader`1.GetChanges(FSharp.Data.Adaptive.AdaptiveToken)">
<summary>
 Dependency-aware evaluation of the reader
</summary>
</member>
<member name="T:FSharp.Data.Traceable.IOpReader`1">
<summary>
 An adaptive reader that allows to get operations since the last evaluation
</summary>
</member>
<member name="T:FSharp.Data.Traceable.CountingHashSetEnumerator`1">
<summary>
 An enumerator for CountingHashSet.
</summary>
</member>
<member name="F:FSharp.Data.Traceable.CountingHashSet`1.traceNoRefCount">
<summary>
 Traceable instance without ref-counting.
</summary>
</member>
<member name="F:FSharp.Data.Traceable.CountingHashSet`1.trace">
<summary>
 Traceable instance.
</summary>
</member>
<member name="P:FSharp.Data.Traceable.CountingHashSet`1.TraceNoRefCount">
<summary>
 Traceable instance without ref-counting.
</summary>
</member>
<member name="P:FSharp.Data.Traceable.CountingHashSet`1.Trace">
<summary>
 Traceable instance.
</summary>
</member>
<member name="P:FSharp.Data.Traceable.CountingHashSet`1.Store">
<summary>
 Internal for getting the store
</summary>
</member>
<member name="P:FSharp.Data.Traceable.CountingHashSet`1.IsEmpty">
<summary>
 Is the set empty?
</summary>
</member>
<member name="P:FSharp.Data.Traceable.CountingHashSet`1.Empty">
<summary>
 The empty set.
</summary>
</member>
<member name="P:FSharp.Data.Traceable.CountingHashSet`1.Count">
<summary>
 The number of entries in the set (excluding ref-counts).
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.UnionWith(FSharp.Data.Traceable.CountingHashSet{`0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32}})">
<summary>
 Unions both sets using resolve to aggregate ref-counts.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Union(FSharp.Data.Traceable.CountingHashSet{`0})">
<summary>
 Unions the two sets.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ToSeq">
<summary>
 All elements in the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ToList">
<summary>
 All elements in the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ToHashSet">
<summary>
 Creates a HashSet with the same entries.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ToHashMap">
<summary>
 Gets the HashMap representation of the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ToArray">
<summary>
 All elements in the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.RemoveAll">
<summary>
 Same as x.ComputeDelta(empty)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Remove(`0)">
<summary>
 Removes the given value from the set. (one reference)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.OfSeq(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Creates a set holding all the given values. (with reference counts)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.OfList(Microsoft.FSharp.Collections.FSharpList{`0})">
<summary>
 Creates a set holding all the given values. (with reference counts)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.OfHashSet(FSharp.Data.Adaptive.FSharpHashSet{`0})">
<summary>
 Creates a set holding all the given values.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.OfHashMap(FSharp.Data.Adaptive.FSharpHashMap{`0,System.Int32})">
<summary>
 Creates a set holding all the given values. (with reference counts)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.OfArray(`0[])">
<summary>
 Creates a set holding all the given values. (with reference counts)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Map``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Creates a new set by applying the given function to all elements.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Iter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Iterates over all set elements. (once)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Intersect(FSharp.Data.Traceable.CountingHashSet{`0})">
<summary>
 Computes the intersection of both sets.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.GetRefCount(`0)">
<summary>
 Gets the reference-count for the given value (0 if not contained)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Forall(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Checks whether all elements fulfill the predicate.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Fold``1(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{`0,``0}})">
<summary>
 Folds over all elements in the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Creates a new set filtered by the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Checks whether an element fulfilling the predicate exists.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Difference(FSharp.Data.Traceable.CountingHashSet{`0})">
<summary>
 Computes the set difference for both sets. (this - other)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Contains(`0)">
<summary>
 Checks whether the given value is contained in the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ComputeDelta(FSharp.Data.Traceable.CountingHashSet{`0})">
<summary>
 Differentiates two sets returning a HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Compare(FSharp.Data.Traceable.CountingHashSet{`0},FSharp.Data.Traceable.CountingHashSet{`0})">
<summary>
 Compares two sets.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Collect``1(Microsoft.FSharp.Core.FSharpFunc{`0,FSharp.Data.Traceable.CountingHashSet{``0}})">
<summary>
 Creates a new set with all elements from all created sets.  (respecting ref-counts)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Choose``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Creates a new set by applying the given function to all elements.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ApplyDeltaNoRefCount(FSharp.Data.Adaptive.FSharpHashSetDelta{`0})">
<summary>
 Integrates the given delta into the set, returns a new set and the effective deltas.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.ApplyDelta(FSharp.Data.Adaptive.FSharpHashSetDelta{`0})">
<summary>
 Integrates the given delta into the set, returns a new set and the effective deltas.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Alter(`0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
<summary>
 Changes the reference-count for the given element.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.AddAll">
<summary>
 Same as empty.ComputeDelta(x)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSet`1.Add(`0)">
<summary>
 Adds the given value to the set. (one reference)
</summary>
</member>
<member name="T:FSharp.Data.Traceable.CountingHashSet`1">
<summary>
 A reference counting set, used for tracing the unions of sets with elements in common.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.SetCmp">
<summary>
 Set comparison result.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.IndexList.Traceable`1">
<summary>
 Type for caching the Traceable&lt;_&gt; instance for IndexList&lt;_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Traceable.IndexList.trace``1">
<summary>
 The traceable instance for HashSet.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.IndexList">
<summary>
 Functional operators for IndexList.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HashMap.TraceableInstance`2">
<summary>
 Type for caching the Traceable&lt;_&gt; instance for HashMap&lt;_,_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Traceable.HashMap.trace``2">
<summary>
 The traceable instance for HashSet.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HashMap">
<summary>
 Functional operators for HashMap.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HashSet.Traceable`1">
<summary>
 Type for caching the Traceable&lt;_&gt; instance for HashSet&lt;_&gt;
</summary>
</member>
<member name="M:FSharp.Data.Traceable.HashSet.trace``1">
<summary>
 The traceable instance for HashSet.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HashSet">
<summary>
 Functional operators for HashSet.
</summary>
</member>
<member name="F:FSharp.Data.Traceable.HashMapDelta.Monoid`2.monoid">
<summary>
 The monoid instance for HashMapDelta
</summary>
</member>
<member name="M:FSharp.Data.Traceable.HashMapDelta.monoid``2">
<summary>
 The monoid instance for HashMapDelta
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HashMapDelta">
<summary>
 Functional operators for HashMapDelta.
</summary>
</member>
<member name="F:FSharp.Data.Traceable.IndexListDelta.Monoid`1.monoid">
<summary>
 The monoid instance for HashSetDelta
</summary>
</member>
<member name="M:FSharp.Data.Traceable.IndexListDelta.monoid``1">
<summary>
 The monoid instance for HashSetDelta
</summary>
</member>
<member name="T:FSharp.Data.Traceable.IndexListDelta">
<summary>
 Functional operators for IndexListDelta.
</summary>
</member>
<member name="F:FSharp.Data.Traceable.HashSetDelta.Monoid`1.monoid">
<summary>
 The monoid instance for HashSetDelta
</summary>
</member>
<member name="M:FSharp.Data.Traceable.HashSetDelta.monoid``1">
<summary>
 The monoid instance for HashSetDelta
</summary>
</member>
<member name="T:FSharp.Data.Traceable.HashSetDelta">
<summary>
 Functional operators for HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.History.ofReader``2(FSharp.Data.Traceable.Traceable{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Data.Traceable.IOpReader{``1}})">
<summary>
 Creates a history depending on the given reader. 
 The history will internally use the given traceable instance.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.History.Readers.ConstantReader`2">
<summary>
 A constant reader.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.History.Readers.EmptyReader`2">
<summary>
 The empty reader.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.History.Readers">
<summary>
 Simple base-types for reader implementations.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.History">
<summary>
 Functional operators related to the History&lt;_,_&gt; type.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.compare``1(FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Compares two sets.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.applyDeltaNoRefCount``1(FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Integrates the given delta into the set without ref-counting, returns a new set and the effective deltas.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.applyDelta``1(FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Adaptive.FSharpHashSetDelta{``0})">
<summary>
 Integrates the given delta into the set, returns a new set and the effective deltas.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.addAll``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Same as computeDelta empty src.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.removeAll``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Same as computeDelta src empty.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.computeDelta``1(FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Differentiates two sets returning a HashSetDelta.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.traceNoRefCount``1">
<summary>
 Traceable instance without ref-counting.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.trace``1">
<summary>
 Traceable instance.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Data.Traceable.CountingHashSet{``1})">
<summary>
 Folds over all elements in the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Checks whether all elements fulfill the predicate.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Checks whether an element fulfilling the predicate exists.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Iterates over all set elements. (once)    
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Data.Traceable.CountingHashSet{``1}},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Creates a new set with all elements from all created sets. (respecting ref-counts)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Creates a new set filtered by the given predicate.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Creates a new set by applying the given function to all elements.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Creates a new set by applying the given function to all elements.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.alter``1(``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Changes the reference-count for the given element.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.intersect``1(FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Computes the intersection of both sets.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.difference``1(FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Computes the set difference for both sets. (l - r)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.union``1(FSharp.Data.Traceable.CountingHashSet{``0},FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Unions the two sets.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.remove``1(``0,FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Removes the given value from the set. (one reference)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.add``1(``0,FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Adds the given value to the set. (one reference)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.contains``1(``0,FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Checks whether the given value is contained in the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.refcount``1(``0,FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Gets the reference-count for the given value (0 if not contained)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.count``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 The number of entries in the set (excluding ref-counts).
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.isEmpty``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Is the set empty?
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.ofArray``1(``0[])">
<summary>
 Creates a set holding all the given values.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates a set holding all the given values.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a set holding all the given values.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.ofHashSet``1(FSharp.Data.Adaptive.FSharpHashSet{``0})">
<summary>
 Creates a set holding all the given values.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.ofHashMap``1(FSharp.Data.Adaptive.FSharpHashMap{``0,System.Int32})">
<summary>
 Creates a set from the given HashMap containing ref-counts.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.toHashSet``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 A HashSet containing all elements from the set.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.toArray``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 An array containing all elements from the set. (once)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.toList``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 A list containing all elements from the set. (once)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.toSeq``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 A seq containing all elements from the set. (once)
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.toHashMap``1(FSharp.Data.Traceable.CountingHashSet{``0})">
<summary>
 Creates a HashMap with all the contained values and ref-counts.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.single``1(``0)">
<summary>
 A set holding a single value.
</summary>
</member>
<member name="M:FSharp.Data.Traceable.CountingHashSetModule.empty``1">
<summary>
 The empty set.
</summary>
</member>
<member name="T:FSharp.Data.Traceable.CountingHashSetModule">
<summary>
 Functional operators for CountingHashSet.
</summary>
</member>
</members>
</doc>
